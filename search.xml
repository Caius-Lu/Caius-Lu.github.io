<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python手册]]></title>
    <url>%2F2019%2F08%2F28%2Fpython%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[最近在学习查找资料的过程之中，看到了大佬的博客，觉得写得很好，也是我现在所欠缺的，所以下面先对大佬的博客进行复现。以供自己日后复习，查找，完善成自己的东西。 字符串固定字数，不足的空格补齐12345str.ljust(10) # 左对齐 字符串长10位rjust，ljust和center三个方法来给字符串补全空格rjust，向右对其，在左边补空格ljust，向左对其，在右边补空格center，让字符串居中，在左右补空格 排序sorted: 返回一个新的 listlist.sort(): 改变 list 自身的值reverse 参数: 默认为 False, 升序, True 时变为降序 列表循环删除列表元素常见错误: 直接删除, 或者正序删除 正确做法: 1.使用 pop, 倒序删除12for i in range(len(list)): list.pop() 2.使用切片, 遍历拷贝列表, 操作原始列表, 用 remove 删除, remove 会操作首个遇到的匹配元素, 相等元素删除, 删除哪个都一样 12345for x in enumerate(a[::]): a.remove(x)for x in enumerate(a[::-1]): a.remove(x) 遍历列表:123456789101112131415161718192021222324252627zz_list = ['a', 'b', 'c', 'd']for index in list: print(index) # 0 # 1 # 2 # 3for index in range(len(list)): print(index) # 0 # 1 # 2 # 3for index, val in enumerate(list): print(index, val) # 0 a # 1 b # 2 c # 3 d# 设置遍历的开始序号, val的输出不变for i, val in enumerate(list, 2): print(index, val) # 2 a # 3 b # 4 c # 5 d append() 方法追加单个元素 extend() 方法extend()函数用于在列表末尾一次性追加另一个序列中的多个值(用新列表扩展原来的列表).该方法没有返回值, 会直接在已经存在的列表中添加新的列表内容, extend和+=的作用差不多12345a= [[1,2,3],[4,5,6]]b= [['a','b','c'],['d','e','f']]a.extend(b)print(a)# [[1, 2, 3], [4, 5, 6], ['a', 'b', 'c'], ['d', 'e', 'f']] 序列切片(双冒号)Python序列切片地址可以写为 [开始(包含) : 结束(不包含) : 步长]. 当开始省略的时候, 默认从第0项开始, 当结尾省略的时候, 默认到数组最后, 当步长省略的时候, 默认为1. 步长可以为负数, 代表从右向左取数.123456a = range(10) # a = [0, 1, 2, 3, 4, 5, 6, 7, 8 ,9]a[0:9:1] # [0, 1, 2, 3, 4, 5, 6, 7, 8] 包含开始下标, 不包含结束下标a[1::2] # [1, 3, 5, 7, 9]a[::3] # [0, 3, 6, 9]a[::-1] # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]a[::-2] # [9, 7, 5, 3, 1] update() 方法1dict.update(dict2) 将 dict2 中的键值更新到 dict 中, 对于存在的则覆盖原值, 对于不存在的则添加新的键值. 实例1234567#!/usr/bin/pythondict = &#123;'Name': 'Zara', 'Age': 7&#125;dict2 = &#123;'Sex': 'female' &#125;dict.update(dict2)print "Value : %s" % dict 以上实例输出结果为：1Value : &#123;'Age': 7, 'Name': 'Zara', 'Sex': 'female'&#125; 字典遍历字典:1zz_dict = &#123;'x': 1, 'y':2, 'z':3&#125; 遍历keys:123456789# 输出均为: x y zfor key in zz_dict: print(key)for key in zz_dict.iterkeys(): print(key)for key in zz_dict.keys(): print(key) 遍历values:123456# 输出均为 1 2 3for value in zz_dict.itervalues(): print(value)for value in zz_dict.values(): print(value) 遍历keys和values123456# 输出为: x corresponds to 1 (其余两个也一样)for key, value in zz_dict.iteritems(): # python3 没有iteritems print(key, "corresponds to", value)for key, value in zz_dict.items(): print(key, "corresponds to", value) 字符串判断字符串是否为字母或者数字str.isalnum() 字母或数字str.isalpha() 字母str.isdigit() 数字str.isspace() 空白符, \t, \n, \r isdigit() 和 isnumeric() 的区别123456789101112131415161718192021222324num = "1" #unicodenum.isdigit() # Truenum.isdecimal() # Truenum.isnumeric() # Truenum = "1" # 全角num.isdigit() # Truenum.isdecimal() # Truenum.isnumeric() # Truenum = b"1" # bytenum.isdigit() # Truenum.isdecimal() # AttributeError 'bytes' object has no attribute 'isdecimal'num.isnumeric() # AttributeError 'bytes' object has no attribute 'isnumeric'num = "IV" # 罗马数字num.isdigit() # Truenum.isdecimal() # Falsenum.isnumeric() # Truenum = "四" # 汉字num.isdigit() # Falsenum.isdecimal() # Falsenum.isnumeric() # True isdigit()True: Unicode数字，byte数字（单字节），全角数字（双字节），罗马数字False: 汉字数字Error: 无 isdecimal()True: Unicode数字，，全角数字（双字节）False: 罗马数字，汉字数字Error: byte数字（单字节） isnumeric()True: Unicode数字，全角数字（双字节），罗马数字，汉字数字False: 无Error: byte数字（单字节） str.rstrip()参数:chars: 指定删除的字符(默认为空格或换行符) 返回值:返回删除指定字符后的新字符串 备注:删除字符串末尾的指定字符(默认为空格或换行符)1str.rstrip([chars]) str.strip()参数chars — 移除字符串头尾指定的字符序列。返回值返回移除字符串头尾指定的字符生成的新字符串。备注:1str.strip([chars]) str.split()参数 str — 分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。 num — 分割次数。默认为 -1, 即分隔所有。返回值 返回分割后的字符串列表。1str.split(str="", num=string.count(str)). 文件reduce() 函数reduce() 函数会对参数序列中元素进行累积。函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。reduce() 函数语法：1reduce(function, iterable[, initializer]) 参数 function — 函数，有两个参数 iterable — 可迭代对象 initializer — 可选，初始参数返回值 返回函数计算结果实例1234567&gt;&gt;&gt;def add(x, y) : # 两数相加... return x + y... &gt;&gt;&gt; reduce(add, [1,2,3,4,5]) # 计算列表和：1+2+3+4+515&gt;&gt;&gt; reduce(lambda x, y: x+y, [1,2,3,4,5]) # 使用 lambda 匿名函数15 zip() 函数zip() 函数用于将可迭代的对象作为参数, 将对象中对应的元素打包成一个个 元组 ,然后返回有这些元组组成的 对象. ( 相比于python2中返回列表的方式, 这样做的好处是节约了不少的内存 )可以用list()转换或者dict()转换将对象转换成相应的数据类型如果各个迭代器的元素个数不一致, 则返回列表长度与最短的对象相同, 多出来的部分会被舍弃, 利用*号操作符, 可以将元组解压成列表.123456789101112131415161718192021a = [1,2,3]b = [4,5,6]c = ['a','b','c','d','e','f']zip_ab = zip(a,b)print(zip_ab) # &lt;zip object at 0x104605348&gt;print(dict(zip_ab)) # &#123;1: 4, 2: 5, 3: 6&#125;# !!!注意, 一旦将zip_ab转换成dict以后, zip_ab内部就为空了!! 例如, 再次调用上面的语句:print(dict(zip_ab)) # &#123;&#125;# 但是zip_ab对象本身不会消失, 地址仍然不变print(zip_ab) # &lt;zip object at 0x104605348&gt;zip_abc = zip(a,b,c) # 注意, 三个元素的zip是不能转换成dict类型的print(zip_abc) # &lt;zip object at 0x1046054c8&gt;print(list(zip_abc)) # [(1, 4, 'a'), (2, 5, 'b'), (3, 6, 'c')]zip_abc = zip(a,b,c)z_a, z_b, z_c = zip(*zip_abc) # 利用zip(*)可以将zip对象重新解压, 返回类型是元组print(z_a) # (1,2,3)print(z_b) # (4,5,6)print(z_c) # ('a','b','c') getattr() 函数getattr()函数用于返回一个对象的属性值, 语法如下1getattr(object, name[, default]) 参数： object: 对象 name: 字符串, 对象属性 default: 默认返回值, 如果不提供该参数, 在没有对应属性时, 将触发Attributerror实例12345678910111213&gt;&gt;&gt;class A(object):... bar = 1... &gt;&gt;&gt; a = A()&gt;&gt;&gt; getattr(a, 'bar') # 获取属性 bar 值1&gt;&gt;&gt; getattr(a, 'bar2') # 属性 bar2 不存在，触发异常Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'A' object has no attribute 'bar2'&gt;&gt;&gt; getattr(a, 'bar2', 3) # 属性 bar2 不存在，但设置了默认值3&gt;&gt;&gt; dir() 函数可以查看某个类的所有方法和属性1members = [attr for attr in dir(classA)] _var: 在一个模块中以单下划线开头的变量和函数会被默认当做内部函数, 在使用from a_module import * 导入时, 这部分变量和函数不会被导入. 不过如果使用import a_module导入模块时, 仍然可以用a_module._var的形式访问该变量或函数 var_: 有时候, 一个变量的最适合的名称已经被另一个关键字所占用. 在这种情况下, 可以在名称的末尾附加一个下划线来解决冲突. __var: 双下划线前缀会导致Python解释器重写属性名称, 以避免子类中的命名冲突. 举例来说, 如果在class Test中有一个成员__x, 那么当利用内置函数dir(Test)来查看类的属性时, 会发现__x被解释器重命名为_Test__x. 双下划线的名称修饰同样也适用于方法名称. __var__: 双下划线开头和结尾的是一些 Python 的特殊对象, 如类成员的 __init__, __del__, __name__, __call__ 等. Python 官方推荐永远不要讲这样的命名方式应用于自己的变量或函数. 有一种说法是说双下划线建议为类的私有成员, 但是 PEP8 当前的官方版本中并没有明说. _: 有时候我们会用一个独立的下划线作为一个名字, 这通常是用来指示某个变量时临时的或者无关紧要的.类的特殊方法call()在 Python 中, 函数实际上也是一个对象:123f = absprint(f.__name__) # 'abs'print(f(-123)) # 123 从上面可以看出, 函数是一个对象, 当它赋给另一个变量时, 该变量也是一个函数对象, 可以起到与原函数相同的效果. 在 Python 中, 一个类实例也可以变成一个可调用对象, 只需要实现一个特殊方法 __call__() 即可. 下面我们举例把 Person 类变成一个可调用对象:123456789class Person(object): def __init__(self, name, gender): self.name = name self.gender = gender def __call__(self, friend): print(&quot;name:&quot;, self.name) print(&quot;friend:&quot;, friend) 接下来我们就可以将 Person 类的实例对象当做一个函数来使用, 如下所示:1234p = Person('Bob', 'male')p('Tim')# name: Bob# friend: Tim getitem()凡是在类中定义了 __getitem__() 方法, 那么它的实例对象就是可以通过 [] 操作符来访问指定的成员或进行特定的行为, 大多数情况下会将该方法实现成通过索引来方法元素的形式.1234567class DataBase(object): def __init__(self): super(DataBase, self).__init__() self.vals = [1,2,3,4,5] def __getitem__(self, key): return self.vals[key] setitem()使得可以通过 A[3] = 4, B[“a”] = 5 等方式来对类中的元素进行赋值 file()查看模块的路径 len()使得类对象可以使用 Python 的内建方法 len(), 返回你自定义的数值.123456789101112131415class DictDemo: def __init__(self,key,value): self.dict = &#123;&#125; self.dict[key] = value def __getitem__(self,key): return self.dict[key] def __setitem__(self,key,value): self.dict[key] = value def __len__(self): return len(self.dict)dictDemo = DictDemo('key0','value0')print(dictDemo['key0']) #value0dictDemo['key1'] = 'value1'print(dictDemo['key1']) #value1print(len(dictDemo)) #2 repr()1234567891011121314151617181920212223242526272829303132333435363738class Test(object): def __init__(self, value='hello, world!'): self.data = value&gt;&gt;&gt; t = Test()&gt;&gt;&gt; t&lt;__main__.Test at 0x7fa91c307190&gt;&gt;&gt;&gt; print t&lt;__main__.Test object at 0x7fa91c307190&gt;# 看到了么？上面打印类对象并不是很友好，显示的是对象的内存地址# 下面我们重构下该类的__repr__以及__str__，看看它们俩有啥区别# 重构__repr__class TestRepr(Test): def __repr__(self): return 'TestRepr(%s)' % self.data&gt;&gt;&gt; tr = TestRepr()&gt;&gt;&gt; trTestRepr(hello, world!)&gt;&gt;&gt; print trTestRepr(hello, world!)# 重构__repr__方法后，不管直接输出对象还是通过print打印的信息都按我们__repr__方法中定义的格式进行显示了# 重构__str__calss TestStr(Test): def __str__(self): return '[Value: %s]' % self.data&gt;&gt;&gt; ts = TestStr()&gt;&gt;&gt; ts&lt;__main__.TestStr at 0x7fa91c314e50&gt;&gt;&gt;&gt; print ts[Value: hello, world!]# 你会发现，直接输出对象ts时并没有按我们__str__方法中定义的格式进行输出，而用print输出的信息却改变了 str()参见 repr() 代码示例 星号 **: 乘法**: 乘幂 用于函数参数单星号: 将所有参数以 元组(tuple) 的形式导入123456def foo(param1, *param2): print(param1) print(param2)foo(1,2,3,4,5)# 1# (2,3,4,5) 双星号: 将所有参数以 字典 的形式导入123456def bar(param1, **param2): print(param1) print(param2)bar(1, a=2, b=3)# 1# &#123;'a': 2, 'b': 3&#125; 当然这两个用法可以同时出现在一个函数中:12345678910def fun(a, b=10, *args, **kwargs): print(a) print(b) print(args) print(kwargs)fun(1,2,3,4,e=5,f=6)# 1# 2# (3,4)# &#123;'e': 5, 'f': 6&#125; globals() 函数该函数会以字典类型返回当前位置的全部全局变量 stripe()readlines()lambda 函数3.6新功能 f string包的导入机制模块和包的定义模块(module): 用来从逻辑上组织 Python 代码(变量, 函数, 类), 通常是一个.py文件.包(package): 定义了一个由模块和子包组成的 Python 应用程序执行环境, 本质上就是一个有层次的文件目录结果(必须带有一个__init__.py文件) import 的搜索路径 在当前目录下搜索 在环境变量PYTHONPATH中指定的路径列表中搜索 在 Python 安装路径的lib库中搜索Python 所有加载的模型信息都存放在sys.modules结构中, 当import一个模块时, 会按如下步骤来进行: 如果import A, 检查sys.modules中是否已经有A, 如果有则不加载, 如果没有则为A创建module对象, 并加载A; 如果是from A import B, 先为A创建module对象, 再解析A(此时会加载并执行A中的所有代码), 从中寻找B并填充到A的__dict__中.在导入模块的时候, 模块所在文件夹会自动生成一个__pycache__/module_name.cpython-35.pyc的文件.1234import module_name的本质是将module_name.py中的全部代码加载到内存中, 并将其赋值给与模块同名的变量, 这个变量的类型是class&lt;module&gt;.from module_name import name的本质是将指定的变量或者方法导入到当前的文件中import package_name的本质是执行该包下的__init__.py文件, 在执行文件后, 会在package_name目录下生成一个__pycache__/__init__cpython-35.pyc文件.from package_name import *的本质是导入__init__.py文件中的__all__列表(eg. __all__ = [&apos;L2Norm&apos;, &apos;MultiBoxLoss&apos;]). 相对导入和绝对导入绝对导入:12import A.Bfrom A import B 相对导入:12from . import B # . 代表当前路径from ..A import B # .. 代表上层路径, ... 代表上上层路径. 在没有明确指定包结构的情况下, Python 是根据__name__来决定一个模块在包中的结构的, 如果是__main__, 则它本身就是顶层模块, 没有包结构, 如果是A.B.C结构, 则A是顶层模块. Python 的导入方式的不同具有不同的规则: 1.如果是绝对导入, 一个模块只能导入自身的子模块或者和它的顶层模块同级别的模块及其子模块.2.如果是相对导入, 一个模块必须有包结构且只能导入它的顶层模块内部的模块. 如果一个模块被直接运行, 则它自己为顶层模块, 不存在层次结构, 所以也找不到上层(..)的相对路径Python2.x 默认为相对路径导入, 而 Python3.x 默认为绝对路径导入, 这样可以避免导入的子包覆盖掉标准库模块. 通常, 在 Python2.x 中, 我们利用下面的语句来使其导入规则遵循 Python3.x1from __future__ import absolute_import absolute_import的意思并不是将所有的导入都视为绝对导入, 而是指禁用隐式相对导入(implicit relative import), 关于隐式的显示的具体区别, 可以看下面的例子, 假设有如下的包结构:1234567891011121314thing└── __init__.py├── books│ ├── __init__.py│ ├── adventure.py│ ├── history.py│ ├── horror.py│ └── lovestory.py├── furniture│ ├── __init__.py│ ├── armchair.py│ ├── bench.py│ ├── screen.py│ └── stool.py 那么如果想在stool.py中导入bench模块, 则有如下几种方式:123import bench # 隐式相对导入from . import bench # 显式相对导入from furniture import bench # 绝对导入 隐式相对导入没有告诉解释器相对于谁进行导入, 默认相对于当前模块; 而显式相对导入则明确告诉了解释器相对于谁来导入. 以上导入方式的第三种是官方推荐的, 第一种是官方强烈不推荐的, Python3 中第一种导入方式只能用于导入sys.path中的模块.**注意, 还有相对导入的模块不能被直接运行, 会提示如下错误:1234Traceback (most recent call last): File &quot;test.py&quot;, line 8, in &lt;module&gt; from .ssd import SSDModuleNotFoundError: No module named &apos;__main__.ssd&apos;; &apos;__main__&apos; is not a package 另外存在一种情况就是: 假如有两个模块a.py和b.py放在同一个目录下, 则可以直接在a.py中使用import b来导入模块b. 这是为什么呢? 我们上面说了在 Python3.x 中不能使用这种隐式相对导入, 但是这里却可以成功导入, 这是因为此时我们是直接运行a.py, 所以a.py和b.py的目录没有被当做一个包来处理, 因此不涉及相对导入和绝对导入的概念. 因此相对导入和绝对导入仅仅是针对于包而言的. 综合距离存在目录结构如下所示:123456789101112dirRoot└── __init__.py├── file1.py├── file2.py├── dirA│ ├── __init__.py│ ├── a1.py│ └── a2.py├── dirB│ ├── __init__.py│ ├── b1.py│ └── b2.py 直接运行a1.py, 并希望导入a2模块:1234# a1.pyimport a2 # 正确, 此时并未将 dirA 当做包来处理, a1.py 和 a2.py 相当于两个独立的模块from a2 import func_a2 # 正确from .a2 import func_a2 # 错误, 当进行相对导入时, 不能直接运行 直接运行file1.py, 并希望导入a1模块, 同时a1模块中需要导入a2模块:12345678910# file1.pyfrom dirA import a1a1.func_a1() # a1.py 中的函数a1.func_a2() # a1.py 中导入了 a2.py 的函数, 可以直接使用# a1.pyimport a2 # 错误, 此时由于 dirA 中有 __init__.py 文件, 因此会将 dirA 当做包来处理,# 由于 Python3.x 不允许使用隐式的相对导入, 因此该语句非法from a2 import func_a2 # 错误, 原因同上from .a2 import func_a2 # 正确, 当进行相对导入时, 需要使用显式的相对导入 直接运行file1.py, 并希望导入a1模块, 同时a1模块中需要导入dirB/b1模块(跨文件夹导入):12345678910# file1.pyfrom dirA import a1a1.func_a1() # a1.py 中的函数a1.func_a2() # a2.py 中的函数a1.func_b1() # b1.py 中的函数# a1.pyfrom .a2 import func_a2 # 推荐使用绝对导入 from dirA.a1 import func_a2from dirB import b1 # 由于运行的是 file1.py 文件, 因此顶层目录是 dirRootfrom dirB.b1 import func_b1 # 所以可以直接使用 dirB 包 直接运行a1.py, 并希望跨目录的导入dirB/b1模块. 由于这种跨目录的导入超越了顶层路径的限制, 因此必须使用sys.path.append()方法来额外添加搜索路径, 否则无法正常导123456# a1.pyimport syssys.path.append("../") # 将 dirA 的上一次目录添加到搜索路径中from dirB import b1 # 正确, 注意必须先添加 path, 然后再导入from dirB.b1 import func_b1 # 正确from .a2 import func_a2 # 这里是错误的, 当直接执行 a1.py 时, a1.py 中不能包含显式相对导入 获取 python 版本:1print(sys.version_info) 获取包的安装位置1print(cv2) 解析 xml 文件导入:12345import sysif sys.version_info[0] == 2: import xml.etree.cElementTree as ETelse: import xml.etree.ElementTree as ET 解析:12345678910111213xmlfile = ET.parse(xmlfile_path)root = xmlfile.getroot() # 获取根节点root.tag # 标签root.attrib # 属性字典for child in root: # 迭代访问子节点 print(child.tag, child.attrib)# 可以通过索引访问嵌套节点的内容root[0][1].textElement.findall() #Element.find() # python 中 == 和 is 的区别== 只用于判断值是否相等is 用于判断两个对象是否为同一个实例小整数对象池: Python 为了优化速度，使用了小整数对象池，避免为整数频繁申请和销毁内存空间。而Python 对小整数的定义是 [-5, 257)，只有数字在-5到256之间它们的id才会相等，超过了这个范围就不行了，同样的道理，字符串对象也有一个类似的缓冲池，超过区间范围内自然不会相等了 队列 queue在 Python3 中, 原来的Queue模块被重命名为queue, 该模块包含以下三类数据结构: queue.Queue(maxsize=0): FIFO queue, 先进先出队列, 代表普通队列 queue.LifoQueue(maxsize=0): LIFO queue, 后进先出队列, 类似栈的作用 queue.PriorityQueue(maxsize=0): 优先级队列, 类似堆的作用. 默认为小顶堆, 常用形式为元组:(priority_number, data)上面的 maxsize 表明了队列中最大可以容纳的元素数量, 如果超过, 则无法插入. 当 maxsize &lt;= 0 时, 代表元素数量无限制.公有方法(以上三个通用): qsize(): 返回 approximate size, qsize() &gt; 0 不保证get()一定 work, 同理, qsize() &lt; maxsize 不保证put()一定 work. empty(): 如果队列为空, 返回 True. 和qsize()一样, 不提供保证性. full(): 如果队列满, 返回 True. 不提供保证性 put(item[, block[, timeout]]) put_nowait(item): 等价于put(item, False) get([block[, timeout]]) get_nowait(): 等价于get(False) task_done(): join():堆 heapqheapq 模块只有最小堆的功能, 要实现最大堆, 需要在入堆和出堆的时候取反, 并且 heapq 模块只能作用于数值型类型.最大堆: _heapify_max(), _heappop_max() 给定一组数据, 创建堆, 两种方式(二者等价):1234567import heapqdata = [1,3,6,2,8,5]heap = []for d in data: heapq.heappush(heap, n) # 方法一 逐个构建heapq.heapify(data) # 方法二 原地构建, 效率更高 小顶堆:123456heap = [1,3,6,2,8,5]heapq.heapify(heap)heapq.heappop(heap) # 返回并删除堆顶heapq.heapreplace(heap, 10) # 删除堆顶并添加新值heapq.heappushpop(heap, 10) # 先将新值加入堆中, 然后立刻弹出堆顶print(heap[0]) # 查看堆顶 大顶堆:123456789101112# 方法一: 取负值heap = [-1,-3,-6,-2,-8,-5]# 方法二: 内置方法heap = [1,3,6,2,8,5]heapq._heapify_max(heap) # max_heapprint(heap[0]) # 查看堆顶, 8heapq._heappop_max(heap) # po from maxheapprint(heap[0]) # 6heapq._heapreplace_max(heap, 10)print(heap[0]) # 10# heapq._heappushpop_max(heap, 10) # 注意, 没有 _heappushpop_max 函数 Python 刷题常用队列:123456789101112import Queuebase_queue = Queue.Queue() # 基本队列, 先进先出base_queue.put(x)base_queue.get()lifo_queue = Queue.LifoQueue() # 先进后出, 类似栈lifo_queue.put(x)lifo_queue.get()prio_queue = Queue.PriorityQueue() # 优先队列, 与C++中priority_queue类似, 可实现堆的功能prio_queue.put(x)prio_queue.get() numpy 中vstack, hstack, concatenate 和 stack 之间的区别和联系concatenate1numpy.concatenate((a1, a2, ...), axis=0, out=None) concatenate 的作用就是将多个数组序列按照axis指定的维度连接起来, 这些数组序列 a1, a2, … 必须保证 除了 axis 指定维度之外的其他维度具有相同的 shape. 注意: 这里的维度指的是a1, a2的维度, 而不是(a1, a2)的维度 从维度角度来更好理解 concatenate 的作用concatenate 执行后的 shape 特定是: axis 指定的维度是多个数组序列对应维度的数值和, 而其他维度保持不变. 也就是说不会增加新的维度, 这是 concatenate 与 stack 之间的一个重要的区别. 如下所示:12345678910111213141516171819202122import numpy as npa1 = np.array([[1, 1], [2, 2], [3, 3]]) # shape = 3x2a2 = np.array([[1, 1], [2, 2]]) # shape = 2 x 2print(a1.shape, a2.shape)concat1 = np.concatenate((a1, a2), axis=0)print(concat1.shape) # shape 为 [5, 2], 在 0 维度上为 3+2, 其他维度保持不变print(concat1) # a1, a2 维度 0 不同, 一个为 3, 一个为 2, 其他维度相同, 均为 2#[[1 1]# [2 2]# [3 3]# [1 1]# [2 2]]#print(np.concatenate((a1, a2), axis=1)) # 由于维度 0 二者不同, 无法保持不变, 因此报错a1 = np.array([[1, 2, 3]]) # shape = 1x3a2 = np.array([[1, 2]]) # shape = 1x2print(a1.shape, a2.shape)concat2 = np.concatenate((a1, a2), axis=1)print(concat2.shape) # shape 为 [1, 5]在 1 维度上为 3 + 2, 0 维度上保持 1 不变print(concat2)# [[1 2 3 1 2]]# print(np.concatenate((a1, a2), axis=0)) # 维度 1 不同, 报错 有时候, concatenate的第一个参数只会传送一个一个数组序列, 这时候, 等价于将这个数组序列的第一维的元素看做是多个数组序列作为concatenate的参数进行传递. 如下所示:123456789a = [[1, 2, 3], [1, 2, 3]]print(np.concatenate(a, axis=0)) # 该行与下一行等价print(np.concatenate((a[0], a[1]), axis=0))a = [[1, 2, 3], [1, 2]]print(np.concatenate(a, axis=0)) # 可以看出, 虽然 a 的第一维度为 2, 第二维度为 3 和 2# 但是, 我们要将其拆分, 拆分后, a[0], a[1] 的第一维度3和2, 其他维度相同, 因此可以在第一维度上进行连接print(np.concatenate((a[0], a[1]), axis=0)) stack12numpy.stack(arrays, axis=0, out=None)numpy.stack((a1, a2, ...), axis=0, out=None) stack 的作用就是将多个数组序列按照axis指定的维度 堆叠 起来, 这些数组序列 a1, a2, … 必须保证 所有维度都相同, 注意这里与 concatenate 的区别. 要更好的理解stack, 可以借助 维度 的概念进行理解, 对于 shape 相同的 k 个数组序列来说, stack 的作用相当于新插入一个维度, 维度的大小为 k, 插入的位置为axis指定的位置. 如下所示:123456789101112131415a1 = [[1, 1], [2, 2], [3, 3]] # shape = 3x2a2 = [[4, 4], [5, 5], [6, 6]] # shape = 3x2a3 = [[7, 7], [8, 8], [9, 9]] # shape = 3x2a4 = [[0, 0], [0, 0], [0, 0]] # shape = 3x2stack1 = np.stack((a1, a2, a3, a4), axis=0) # 新插入维度大小为 4, 位置为第 0 维print(stack1.shape) # shape 为 (4, 3, 2)print('###\n', stack1) # 先将 shape 画好, 然后进行填充, 在第 0 维上进行堆叠, 因此 stack1[*][*] = a1[0], a1[1], ..., a4[2]stack2 = np.stack((a1, a2, a3, a4), axis=1) # 新插入维度大小为 4, 位置为第 1 维print(stack2.shape) # shape 为 (3, 4, 2)print('###\n', stack2) # 在第 1 维上进行堆叠, 因此 stack2[*][*] = a1[0], a2[0], a3[0], a1[1], ...stack3 = np.stack((a1, a2, a3, a4), axis=2) # 新插入维度大小为 4, 位置为第 2 维print(stack3.shape) # shape 为 (3, 2, 4)print('###\n', stack3) # 在第 2 维上进行堆叠, 因此 stack2[*][*] = [1 4 7 0], [1 4 7 0], [2 5 8 0], ... hstack 和 vstackhstack 和 vstack 虽然名字中都带有 stack, 但是实际上, 它们和np.stack的关系并不大, 一个明显的区别就是np.stack要求进行堆叠的多个数组序列需要保证 shape 完全相同, 并且堆叠后会新增加一个由axis指定的维度. 实际上, hstack 和 vstack 可以看做是特殊的 concatenate, 它们在某些情况下可以用 concatenate 来代替 既然 hstack 和 vstack 是特殊的 concatenate, 也就是说, 它们所接受的多个数组序列在axis指定的维度上可以不同, 而在其他维度上必须相同. vstack: 在垂直方向上将多个数组序列进行堆叠, 相当于在axis=0维度上执行concatenatehstack: 在水平方向上将多个数组序列进行堆叠, 相当于在axis=1维度上执行concatenate1234567891011121314151617181920a = [[1, 1], [2, 2], [3, 3]] # shape = 3x2b = [[4, 4], [5, 5], [6, 6]] # shape = 3x2c = [[7, 7], [8, 8], [9, 9]] # shape = 3x2d = [[0, 0], [0, 0], [0, 0]] # shape = 3x2v = np.vstack((a, b, c, d))print(v.shape) # (12, 2)print(v)x = np.concatenate((a, b, c, d), axis = 0) # 等价于 vstackprint(x.shape) # 12, 2print(x)h = np.hstack((a, b, c, d))print(h.shape) # (3, 8)print(h)x = np.concatenate((a, b, c, d), axis = 1) # 等价于 hstackprint(x.shape) # 3, 8print(x) 需要特别注意, 当多个数组序列是一维数组时, 应该先将一维数组转换成二维数组, 然后才能与相应的 concatenate 进行等价. 这是因为, 在数组序列是一维数组时, concatenate 是无法使用axis=1的, 因此此时的 hstack 相当于是在axis=0上进行 concatenate, 而 vstack 则需要先将数组的 shape 从 (N,) 转换成 (1, N) 后才相当于是在axis=1上进行 concatenate 12345678910111213141516a = np.array([1, 2, 3, 4, 5]) # 当面对的是一维数组时,b = np.array([6, 7, 8, 9, 10])h = np.hstack((a, b))print(h.shape)print(h)con = np.concatenate((a, b), axis=0) # 当 a, b 是一维数组时, hstack 相当于在 axis=0 上进行连接print(con.shape)print(con)v = np.vstack((a, b))print(v.shape)print(v)con = np.concatenate(([a], [b]), axis=0) # 当 a, b 是一维数组时, vstack 相当于将 a, b 先转换成二维 (1, N), 然后在 axis=0 上进行连接print(con.shape)print(con) set 去重对于二维列表, 由于 list 的元素也是 list, 在内存中存储的是首元素地址, 无法直接使用 set, 因此需要先将内部的元素全部全换成 tuple 后, 才能使用 list 去重. 如下所示12345678a = list()a.append([1,2,3])a.append([1,2,3])a.append([1,2,3])a.append([4, 5, 6])# b = set(a) # 报错b = set(map(tuple, a))print(b) # &#123;(4, 5, 6), (1, 2, 3)&#125; 参考链接： https://hellozhaozheng.github.io https://www.runoob.com/python/python-tutorial.html]]></content>
      <categories>
        <category>programs</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广度/宽度优先搜索(BFS)]]></title>
    <url>%2F2019%2F08%2F28%2FBFS%2F</url>
    <content type="text"><![CDATA[前言广度优先搜索 是最简单的图搜索算法之一， 也是许多重要的图算法的原型。Prime的最小生成树算法和Dijkstra的单源最短路径算法都使用了类似广度优先搜索的思想。给定图G=(V,E) 和一个可以识别的源节点 s，广度优先搜索对图G中的边进行系统性的探索来发现可以从源节点，到达所有的节点。该算法能够计算从源结点s到每个可到达的节点的距离(最小的边数)，同时生成一棵“广度优先搜索树”。该树以源结点s为根节点，包括所有可以从s到达的结点。对于每个从源结点s可以到达的结点v，在广度优先搜索树里从结点s到结点v的简单路径所对应的的就是图G中从结点s到结点v的“最短路径”，即包含最少边数的路径，该算法既可以用于有向图也可以用于无向图。广度优先算法之所以如此得名是因为该算法始终是将已经发现的结点和未发现结点之间的边界，沿其广度方向向外扩展。也就是说，算法需要在发现所有距离源结点s为k的所有结点之后，才会发现距离源结点s为k+1的 其他结点。 图的概念 图(graph) 是一种$\textcolor{Blue}{网状数据} $结构， 图是由非空的顶点集合和一个描述顶点之间的关系的集合组成。 图由顶点和边组成，顶点表示对象，边表示对象之间的连接关系。 边也可以带权值，称为带权值图。无向图术语 两个顶点之间如果有边连接，视为两个顶点相邻 相邻顶点间的序列称为路径 起点和终点重合的路径称为圈 顶点连接的边数叫做这个顶点的度 没有圈的连通图，就是树 没有圈的非连通图，就是森林 一棵树的边数等于顶点数-1 边数等于顶点数-1 的连通图，就是树 12345678910111213141516171819BFS(G,s) \\for each vertex u \in G.V -&#123;s&#125;\\ u.color = WHITE\\ u.d = \infty\\ u.\pi = NIL\\s.color = GRAY\\s.d = 0\\s.\pi = NIL\\Q = \emptyset\\ENQUEUE(Q,s)\\while Q\neq = \emptyset\\ u = DEQUEUE(Q)\\ for each v \in G.Adj[u]\\ if v.color == WHITE\\ v.color = GRAY\\ v.d = u.d+1\\ v.\pi = u\\ ENQUEUE(Q,v)\\ u.color = BLACK\\ 广度优先搜索的流程图 实例POJ3984《迷宫问题》定义一个二维数组：int maze[5][5] = { 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0,};它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。 解题思路队列是先进后出，后进先出。 对应于题目的输入数组：0, 1, 0, 0, 0,0, 1, 0, 1, 0,0, 0, 0, 0, 0,0, 1, 1, 1, 0,0, 0, 0, 1, 0,把节点定义为(x,y)，(x,y)表示数组maze的项maze[x][y]。于是起点就是(0,0)，终点是(4,4)。按照刚刚的思路，手工梳理一遍：初始条件：起点Vs为(0,0)终点Vd为(4,4)灰色节点集合Q={}初始化所有节点为白色节点下面开始广度优先搜索：1.起始节点Vs变成灰色，加入队列Q，Q={(0,0)}2.取出队列Q的头一个节点Vn，Vn={0,0}，Q={}3.把Vn={0,0}染成黑色，取出Vn所有相邻的白色节点{(1,0)}4.不包含终点(4,4)，染成灰色，加入队列Q，Q={(1,0)}5.取出队列Q的头一个节点Vn，Vn={1,0}，Q={}6.把Vn={1,0}染成黑色，取出Vn所有相邻的白色节点{(2,0)}7.不包含终点(4,4)，染成灰色，加入队列Q，Q={(2,0)}8.取出队列Q的头一个节点Vn，Vn={2,0}，Q={}9.把Vn={2,0}染成黑色，取出Vn所有相邻的白色节点{(2,1), (3,0)}10.不包含终点(4,4)，染成灰色，加入队列Q，Q={(2,1), (3,0)}11.取出队列Q的头一个节点Vn，Vn={2,1}，Q={(3,0)}12.把Vn={2,1}染成黑色，取出Vn所有相邻的白色节点{(2,2)}13.不包含终点(4,4)，染成灰色，加入队列Q，Q={(3,0), (2,2)}14.持续下去，知道Vn的所有相邻的白色节点中包含了(4,4)……15.此时获得了答案]]></content>
      <categories>
        <category>programs</category>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维数组中的查找]]></title>
    <url>%2F2019%2F08%2F27%2F%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 时间限制：1秒 空间限制：32768K 热度指数：1323359 题目解析已知从左到右、从上导线都呈递增关系，令行row为0，令列col为第一行最后一位，然后将target与第一行最后一个数进行比较，若大于这个数则，行数++，若小于这个数，则列数向前递减。题目的要求是 当目标数target既不大于也不小于array[row][col]，认为target==array[row][col]，返回true。其他的情况则返回false。注： 在 c++中获取vector数组的行数和列数的代码与java不一样 123456c++:int col = array[0].size()-1;int row = array.size();java:int col = array[0].length - 1;int array_len = array.length; c++代码 如下：12345678910111213141516171819202122232425262728class Solution &#123;public: //行数： //example.length // 列数： //example[0].length //第0行的列数 bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123; if(array.size()==0) &#123; return false; &#125; int row = 0; int col = array[0].size()-1; int array_len = array.size(); while(row &lt;array_len &amp;&amp; col&gt;=0 ) &#123; if(target&gt; array[row][col]) row++; else if(target&lt; array[row][col]) col--; else return true; &#125; return false; &#125;&#125;; 运行时间：11ms占用内存：1500k]]></content>
      <categories>
        <category>programs</category>
        <category>algorithm</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿射变换]]></title>
    <url>%2F2019%2F08%2F26%2F%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[欧式变换包括平移和旋转变换 什么是仿射变换？ 简单的来说“仿射变换” 就是：“线性变换”+平移尺度变换包括相似变换，当x与y变换的尺度相等的时候，叫做相似变换什么是线性变换？ 1 线性变换 线性变换从几何直观有三个 要点： 变换前是直线的，变换后依旧是直线 直线比例保持不变 变换前是原点，变换后依然是原点 2 仿射变换仿射变换从几何直观只有两个要点： 变换前是直线的，变换后依然是直线 直线比例保持不变* 与线性变换相比少了原点保持不变这一条]]></content>
      <categories>
        <category>maths</category>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSD源码解析]]></title>
    <url>%2F2019%2F08%2F24%2Fssd%2F</url>
    <content type="text"><![CDATA[论文地址: SSD: Single Shot MultiBox Detector 非官方代码: pytorch 介绍SSD，全称Single Shot MultiBox Detector，是一种One-Stage的方法，它由Wei Liu在ECCV 2016上提出，SSD具有如下主要特点： 从YOLO中继承了将detection转化为regression的思路，同时一次即可完成网络训练 基于Faster RCNN中的anchor，提出了相似的prior box 加入基于特征金字塔（Pyramidal Feature Hierarchy）的检测方式，相当于半个FPN思路 SSD的 网络结构 由上图可以看出，SSD的基础网络结构由基础网络VGG16组成，在VGG16基础网络之后接了一个3x3的卷积和一个1x1的卷积做特征融合，然后增加了一个Extra Feature Layers 层，这个层由八个卷积层构成。SSD在前面的基础网络去conv_4_3之后的relu层输出，以及倒数第二层的conv_7_1的relu再加上Extra Feature Layers层的第1,3,5,7层 共有6个 featuremap层，在此基础上对box进行预测。但感觉要提升效果的话可以对基础网络进行更改，增加特征融合等等。 空洞卷积(Dilation Conv) ssd网络里还使用了空洞卷积(Dilation Conv),采用VGG16做基础模型，首先VGG16是在ILSVRC CLS-LOC数据集预训练。然后借鉴了DeepLab-LargeFOV，分别将VGG16的全连接层fc6和fc7转换成 3×3卷积层 conv6和 1×1 卷积层conv7，同时将池化层 pool5 由原来的 stride=2 的 2×2 变成 stride=1 的(猜想是不想reduce特征图大小)，为了配合这种变化，采用了一种 Atrous Algorithm，其实就是conv6采用扩展卷积或带孔卷积（Dilation Conv），其在不增加参数与模型复杂度的条件下指数级扩大卷积的视野，其使用扩张率(dilation rate)参数，来表示扩张的大小，如下图所示，(a)是普通的 3×3 卷积，其视野就是 3×3 ，(b)是扩张率为 1，此时视野变成 7×7 ，(c)扩张率为3时，视野扩大为 15×15 ，但是视野的特征更稀疏了。Conv6采用 3×3 大小但dilation rate=6的扩展卷积。 Prior Box SSD中有着类似anchor机制的Prior Box机制，用于来生成先验框，后面将这些先验框与真实的gt进行匹配，然后与预测的进行回归。从而得到物体真实的 位置。SSD的prior Box 按照如下规则生成： 以feature map上每个点的中点为中心（offset=0.5），生成一些列同心的prior box（然后中心点的坐标会乘以step，相当于从feature map位置映射回原图位置） 正方形prior box最小边长为’’’pash $min_size$’’’，最大边长为：\sqrt{min_size*max_size}E=mc^2 根据相应的aspect ratio，会生成不同个数的长方形 ，长宽为：$ \sqrt{aspect_ratio}min_size$ 和 $1/ \sqrt{aspect_ratio}min_size$ $f(x)=ax+b$ 最终网络生成固定数量的Prior Box 每个feature map 对应prior box的min_size 和max_size 由以下的公式决定，公式中的m是使用feature map的数量(m=6) S_k = S_min + \frac{S_max-S_min}{m-1}(k-1) , k \in[1,m]第一层feature map对应的min_size=S1，max_size=S2；第二层min_size=S2，max_size=S3；其他类推。在原文中，Smin=0.2，Smax=0.9 min_size max_size def.boxes num conv4_3 30 60 4 fc7 60 111 6 conv6_2 111 162 6 fc7 162 213 6 conv4_3 213 264 4 fc7 264 315 4 训练策略正负样本给定输入图像以及每个物体的Ground Truth,首先找到每个Ground True box对应的default box中IOU最大的最为正样本。然后,在剩下的default box中寻找与Ground Truth 的IOU大于0.5的default box作为正样本。一个Ground Truth可能对应多个正样本default box.其他的default box作为负样本。,为了保证样本尽量平衡,SSD采用了hard nagative mining,即对负样本进行抽样,抽样时按照置信度误差(预测背景的置信度越小,误差越大)进行奖序排列,选取误差较大的top-k作为训练的负样本,保证正负样本比例接近1:3。 目标函数目标函数为训练过程中的优化标准,目标函数也称损失函数,主要包括位置误差(localization loss,loc) 与置信度误差(confidence loss,conf,分类损失)的加权和,定义为： 代码解析基础模型定义1234567891011121314151617181920212223242526# vgg([64, 64, 'M', 128, 128, 'M', 256, 256, 256, 'C', 512, 512, 512, 'M',# 512, 512, 512], 3)# This function is derived from torchvision VGG make_layers()# https://github.com/pytorch/vision/blob/master/torchvision/models/vgg.pydef vgg(cfg, i, batch_norm=False): layers = [] in_channels = i for v in cfg: if v == 'M': layers += [nn.MaxPool2d(kernel_size=2, stride=2)] elif v == 'C': layers += [nn.MaxPool2d(kernel_size=2, stride=2, ceil_mode=True)] else: conv2d = nn.Conv2d(in_channels, v, kernel_size=3, padding=1) if batch_norm: layers += [conv2d, nn.BatchNorm2d(v), nn.ReLU(inplace=True)] else: layers += [conv2d, nn.ReLU(inplace=True)] in_channels = v pool5 = nn.MaxPool2d(kernel_size=3, stride=1, padding=1) conv6 = nn.Conv2d(512, 1024, kernel_size=3, padding=6, dilation=6) conv7 = nn.Conv2d(1024, 1024, kernel_size=1) layers += [pool5, conv6, nn.ReLU(inplace=True), conv7, nn.ReLU(inplace=True)] return layers 1234567891011121314151617181920212223242526272829303132base = &#123; '300': [64, 64, 'M', 128, 128, 'M', 256, 256, 256, 'C', 512, 512, 512, 'M', 512, 512, 512], '512': [],&#125;extras = &#123; '300': [256, 'S', 512, 128, 'S', 256, 128, 256, 128, 256], '512': [],&#125;mbox = &#123; '300': [4, 6, 6, 6, 4, 4], # number of boxes per feature map location '512': [],&#125;def add_extras(cfg, i, batch_norm=False): # Extra layers added to VGG for feature scaling layers =[] in_channel = i flag = False for k,v in enumerate(cfg): if in_channel !="S": if v == "S": layers += [nn.Conv2d(in_channel,cfg[k+1], kernel_size=(1,3)[flag], stride=2,padding=1)] # flag 来控制卷积核是1 还是3 else: layers += [nn.Conv2d(in_channel, v, kernel_size=(1,3)[flag])] flag = not flag in_channel = v return layers 模型Head部分的生成123456789101112131415161718# cfg [4, 6, 6, 6, 4, 4], # number of boxes per feature map locationdef multibox(vgg, extra_layers, cfg, num_classes): loc_layers = [] conf_layers = [] vgg_source = [21, -2] for k, v in enumerate(vgg_source): loc_layers += [nn.Conv2d(vgg[v].out_channels, cfg[k] * 4, kernel_size=3, padding=1)] conf_layers += [nn.Conv2d(vgg[v].out_channels, cfg[k] * num_classes, kernel_size=3, padding=1)] # 对extra_layers中的（Conv2d-2_1、Conv2d-4_1、Conv2d-6_1、Conv2d-8_1）层通过卷积提取特征 for k, v in enumerate(extra_layers[1::2], 2): loc_layers += [nn.Conv2d(v.out_channels, cfg[k] * 4, kernel_size=3, padding=1)] conf_layers += [nn.Conv2d(v.out_channels, cfg[k] * num_classes, kernel_size=3, padding=1)] return vgg, extra_layers, (loc_layers, conf_layers) 模型先验框的生成123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class PriorBox(object): """Compute priorbox coordinates in center-offset form for each source feature map. """ def __init__(self, cfg): super(PriorBox, self).__init__() self.image_size = cfg['min_dim'] # number of priors for feature map location (either 4 or 6) self.num_priors = len(cfg['aspect_ratios']) self.variance = cfg['variance'] or [0.1] self.feature_maps = cfg['feature_maps'] self.min_sizes = cfg['min_sizes'] self.max_sizes = cfg['max_sizes'] self.steps = cfg['steps'] self.aspect_ratios = cfg['aspect_ratios'] self.clip = cfg['clip'] self.version = cfg['name'] for v in self.variance: if v &lt;= 0: raise ValueError('Variances must be greater than 0') def forward(self): mean = [] # 'steps': [8, 16, 32, 64, 100, 300], # 'feature_maps': [38, 19, 10, 5, 3, 1], # 'min_sizes': [21, 45, 99, 153, 207, 261], # 'max_sizes': [45, 99, 153, 207, 261, 315], for k, f in enumerate(self.feature_maps): for i, j in product(range(f), repeat=2): f_k = self.image_size / self.steps[k] # unit center x,y cx = (j + 0.5) / f_k cy = (i + 0.5) / f_k # aspect_ratio: 1 # rel size: min_size s_k = self.min_sizes[k]/self.image_size mean += [cx, cy, s_k, s_k] # aspect_ratio: 1 # rel size: sqrt(s_k * s_(k+1)) s_k_prime = sqrt(s_k * (self.max_sizes[k]/self.image_size)) mean += [cx, cy, s_k_prime, s_k_prime] # rest of aspect ratios for ar in self.aspect_ratios[k]: mean += [cx, cy, s_k*sqrt(ar), s_k/sqrt(ar)] mean += [cx, cy, s_k/sqrt(ar), s_k*sqrt(ar)] # back to torch land output = torch.Tensor(mean).view(-1, 4) if self.clip: output.clamp_(max=1, min=0) return output MultiBox 损失函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155class MultiBoxLoss(nn.Module): """SSD Weighted Loss Function Compute Targets: 1) Produce Confidence Target Indices by matching ground truth boxes with (default) 'priorboxes' that have jaccard index &gt; threshold parameter (default threshold: 0.5). 2) Produce localization target by 'encoding' variance into offsets of ground truth boxes and their matched 'priorboxes'. 3) Hard negative mining to filter the excessive number of negative examples that comes with using a large number of default bounding boxes. (default negative:positive ratio 3:1) Objective Loss: L(x,c,l,g) = (Lconf(x, c) + αLloc(x,l,g)) / N Where, Lconf is the CrossEntropy Loss and Lloc is the SmoothL1 Loss weighted by α which is set to 1 by cross val. Args: c: class confidences, l: predicted boxes, g: ground truth boxes N: number of matched default boxes See: https://arxiv.org/pdf/1512.02325.pdf for more details. # 计算目标: # 输出那些与真实框的iou大于一定阈值的框的下标. # 根据与真实框的偏移量输出localization目标 # 用难样例挖掘算法去除大量负样本(默认正负样本比例为1:3) # 目标损失: # L(x,c,l,g) = (Lconf(x,c) + αLloc(x,l,g)) / N # 参数: # c: 类别置信度(class confidences) # l: 预测的框(predicted boxes) # g: 真实框(ground truth boxes) # N: 匹配到的框的数量(number of matched default boxes) """# MultiBoxLoss(cfg['num_classes'], 0.5, True, 0, True, 3, 0.5, False, args.cuda) def __init__(self, num_classes, overlap_thresh, prior_for_matching, bkg_label, neg_mining, neg_pos, neg_overlap, encode_target, use_gpu=True): super(MultiBoxLoss, self).__init__() self.use_gpu = use_gpu self.num_classes = num_classes # 列表数 21 self.threshold = overlap_thresh # 交并比阈值, 0.5 self.background_label = bkg_label # 背景标签, 0 self.encode_target = encode_target # True 没卵用 self.use_prior_for_matching = prior_for_matching # True, 没卵用 self.do_neg_mining = neg_mining # 负样本和正样本的比例, 3:1 self.negpos_ratio = neg_pos # 0.5 判定负样本的阈值. self.neg_overlap = neg_overlap # False 没卵用 self.variance = cfg['variance'] def forward(self, predictions, targets): """Multibox Loss Args: predictions (tuple): A tuple containing loc preds, conf preds, and prior boxes from SSD net. conf shape: torch.size(batch_size,num_priors,num_classes) loc shape: torch.size(batch_size,num_priors,4) priors shape: torch.size(num_priors,4) targets (tensor): Ground truth boxes and labels for a batch, shape: [batch_size,num_objs,5] (last idx is the label). """ loc_data, conf_data, priors = predictions # loc_data: [batch_size, 8732, 4] # conf_data: [batch_size, 8732, 21] # priors: [8732, 4] default box 对于任意的图片, 都是相同的, 因此无需带有 batch 维度 num = loc_data.size(0) # num = batch_size priors = priors[:loc_data.size(1), :] # loc_data.size(1) = 8732, 因此 priors 维持不变 num_priors = (priors.size(0)) # num_priors = 8732 num_classes = self.num_classes # num_classes = 21 (默认为voc数据集) # match priors (default boxes) and ground truth boxes # 将priors(default boxes)和ground truth boxes匹配 loc_t = torch.Tensor(num, num_priors, 4) # shape:[batch_size, 8732, 4] conf_t = torch.LongTensor(num, num_priors) # shape:[batch_size, 8732] for idx in range(num): # targets是列表, 列表的长度为batch_size, 列表中每个元素为一个 tensor, # 其 shape 为 [num_objs, 5], 其中 num_objs 为当前图片中物体的数量, 第二维前4个元素为边框坐标, 最后一个元素为类别编号(1~20) truths = targets[idx][:, :-1].data # [num_objs, 4] labels = targets[idx][:, -1].data # [num_objs] 使用的是 -1, 而不是 -1:, 因此, 返回的维度变少了 defaults = priors.data # [8732, 4] # from ..box_utils import match # 关键函数, 实现候选框与真实框之间的匹配, 注意是候选框而不是预测结果框! 这个函数实现较为复杂, 会在后面着重讲解 match(self.threshold, truths, defaults, self.variance, labels, loc_t, conf_t, ) if self.use_gpu: loc_t = loc_t.cuda() conf_t = conf_t.cuda() # wrap targets # 用Variable封装loc_t, 新版本的 PyTorch 无需这么做, 只需要将 requires_grad 属性设置为 True 就行了 loc_t = Variable(loc_t, requires_grad=False) conf_t = Variable(conf_t, requires_grad=False) pos = conf_t &gt; 0 # 筛选出 &gt;0 的box下标(大部分都是=0的) num_pos = pos.sum(dim=1, keepdim=True) # 求和, 取得满足条件的box的数量, [batch_size, num_gt_threshold] # Localization Loss (Smooth L1) # Shape: [batch,num_priors,4] # 位置(localization)损失函数, 使用 Smooth L1 函数求损失 # loc_data:[batch, num_priors, 4] # pos: [batch, num_priors] # pos_idx: [batch, num_priors, 4], 复制下标成坐标格式, 以便获取坐标值 pos_idx = pos.unsqueeze(pos.dim()).expand_as(loc_data) loc_p = loc_data[pos_idx].view(-1, 4) # 获取预测结果值 loc_t = loc_t[pos_idx].view(-1, 4) # 获取gt值 loss_l = F.smooth_l1_loss(loc_p, loc_t, size_average=False) # 计算损失 # Compute max conf across batch for hard negative mining # 计算最大的置信度, 以进行难负样本挖掘 # conf_data: [batch, num_priors, num_classes] # batch_conf: [batch, num_priors, num_classes] batch_conf = conf_data.view(-1, self.num_classes) # conf_t: [batch, num_priors] # loss_c: [batch*num_priors, 1], 计算每个priorbox预测后的损失 loss_c = log_sum_exp(batch_conf) - batch_conf.gather(1, conf_t.view(-1, 1)) # 难负样本挖掘, 按照loss进行排序, 取loss最大的负样本参与更新 # Hard Negative Mining loss_c[pos] = 0 # filter out pos boxes for now # 将所有的pos下标的box的loss置为0(pos指示的是正样本的下标) # 将 loss_c 的shape 从 [batch*num_priors, 1] 转换成 [batch, num_priors] loss_c = loss_c.view(num, -1) # reshape # 进行降序排序, 并获取到排序的下标 _, loss_idx = loss_c.sort(1, descending=True) # 将下标进行升序排序, 并获取到下标的下标 _, idx_rank = loss_idx.sort(1) # num_pos: [batch, 1], 统计每个样本中的obj个数 num_pos = pos.long().sum(1, keepdim=True) # 根据obj的个数, 确定负样本的个数(正样本的3倍) num_neg = torch.clamp(self.negpos_ratio*num_pos, max=pos.size(1)-1) # 获取到负样本的下标 neg = idx_rank &lt; num_neg.expand_as(idx_rank) # 计算包括正样本和负样本的置信度损失 # pos: [batch, num_priors] # pos_idx: [batch, num_priors, num_classes] pos_idx = pos.unsqueeze(2).expand_as(conf_data) # neg: [batch, num_priors] # neg_idx: [batch, num_priors, num_classes] neg_idx = neg.unsqueeze(2).expand_as(conf_data) # 按照pos_idx和neg_idx指示的下标筛选参与计算损失的预测数据 conf_p = conf_data[(pos_idx+neg_idx).gt(0)].view(-1, self.num_classes) # 按照pos_idx和neg_idx筛选目标数据 targets_weighted = conf_t[(pos+neg).gt(0)] # 计算二者的交叉熵 loss_c = F.cross_entropy(conf_p, targets_weighted, size_average=False) # Sum of losses: L(x,c,l,g) = (Lconf(x, c) + αLloc(x,l,g)) / N # 将损失函数归一化后返回 N = num_pos.data.sum() loss_l /= N loss_c /= N return loss_l, loss_c match函数的解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566def match(threshold, truths, priors, variances, labels, loc_t, conf_t, idx): # threshold: (float) 确定是否匹配的交并比阈值 # truths: (tensor: [num_obj, 4]) 存储真实 box 的边框坐标 # priors: (tensor: [num_priors, 4], 即[8732, 4]), 存储推荐框的坐标, 注意, 此时的框是 default box, 而不是 SSD 网络预测出来的框的坐标, 预测的结果存储在 loc_data中, 其 shape 为[num_obj, 8732, 4]. # variances: cfg['variance'], [0.1, 0.2], 用于将坐标转换成方便训练的形式(参考RCNN系列对边框坐标的处理) # labels: (tensor: [num_obj]), 代表了每个真实 box 对应的类别的编号 # loc_t: (tensor: [batches, 8732, 4]), # conf_t: (tensor: [batches, 8732]), # idx: batches 中图片的序号, 标识当前正在处理的 image 在 batches 中的序号 # jaccard index overlaps = jaccard( # [A, B], 返回任意两个box之间的交并比, overlaps[i][j] 代表box_a中的第i个box与box_b中的第j个box之间的交并比. truths, point_form(priors) ) # 二部图匹配(Bipartite Matching) # [num_objs,1], 得到对于每个 gt box 来说的匹配度最高的 prior box, 前者存储交并比, 后者存储prior box在num_priors中的位置 best_prior_overlap, best_prior_idx = overlaps.max(1, keepdim=True) # keepdim=True, 因此shape为[num_objs,1] # [1,num_priors] best ground truth for each prior # [1, num_priors], 即[1,8732], 同理, 得到对于每个 prior box 来说的匹配度最高的 gt box best_truth_overlap, best_truth_idx = overlaps.max(0, keepdim=True) best_truth_idx.squeeze_(0) # 上面特意保留了维度(keepdim=True), 这里又都把维度 squeeze/reduce 了, 实际上只需用默认的 keepdim=False 就可以自动 squeeze/reduce 维度. best_truth_overlap.squeeze_(0) best_prior_idx.squeeze_(1) best_prior_overlap.squeeze_(1) best_truth_overlap.index_fill_(0, best_prior_idx, 2) # ensure best prior # 维度压缩后变为[num_priors], best_prior_idx 维度为[num_objs], # 该语句会将与gt box匹配度最好的prior box 的交并比置为 2, 确保其最大, 以免防止某些 gtbox 没有匹配的 priorbox. # 假想一种极端情况, 所有的priorbox与某个gtbox(标记为G)的交并比为1, 而其他gtbox分别有一个交并比 # 最高的priorbox, 但是肯定小于1(因为其他的gtbox与G的交并比肯定小于1), 这样一来, 就会使得所有 # 的priorbox都与G匹配, 为了防止这种情况, 我们将那些对gtbox来说, 具有最高交并比的priorbox, # 强制进行互相匹配, 即令best_truth_idx[best_prior_idx[j]] = j, 详细见下面的for循环 # TODO refactor: index best_prior_idx with long tensor # ensure every gt matches with its prior of max overlap # 注意!!: 因为 gt box 的数量要远远少于 prior box 的数量, 因此, 同一个 gt box 会与多个 prior box 匹配. for j in range(best_prior_idx.size(0)): best_truth_idx[best_prior_idx[j]] = j # best_prior_idx[j] 代表与box_a的第j个box交并比最高的 prior box 的下标, 将与该 gtbox # 匹配度最好的 prior box 的下标改为j, 由此,完成了该 gtbox 与第j个 prior box 的匹配. # 这里的循环只会进行num_obj次, 剩余的匹配为 best_truth_idx 中原本的值. # 这里处理的情况是, priorbox中第i个box与gtbox中第k个box的交并比最高, # 即 best_truth_idx[i]= k # 但是对于best_prior_idx[k]来说, 它却与priorbox的第l个box有着最高的交并比, # 即best_prior_idx[k]=l # 而对于gtbox的另一个边框gtbox[j]来说, 它与priorbox[i]的交并比最大, # 即但是对于best_prior_idx[j] = i. # 那么, 此时, 我们就应该将best_truth_idx[i]= k 修改成 best_truth_idx[i]= j. # 即令 priorbox[i] 与 gtbox[j]对应. # 这样做的原因: 防止某个gtbox没有匹配的 prior box. matches = truths[best_truth_idx] # Shape: [num_priors,4] # truths 的shape 为[num_objs, 4], 而best_truth_idx是一个指示下标的列表, 列表长度为 8732, # 列表中的下标范围为0~num_objs-1, 代表的是与每个priorbox匹配的gtbox的下标 # 上面的表达式会返回一个shape为 [num_priors, 4], 即 [8732, 4] 的tensor, 代表的就是与每个priorbox匹配的gtbox的坐标值. conf = labels[best_truth_idx] + 1 # 与上面的语句道理差不多, 这里得到的是每个prior box匹配的类别编号, shape 为[8732] conf[best_truth_overlap &lt; threshold] = 0 # 将与gtbox的交并比小于阈值的置为0 , 即认为是非物体框 loc = encode(matches, priors, variances) # 返回编码后的中心坐标和宽高. loc_t[idx] = loc # [num_priors,4] encoded offsets to learn # 设置第idx张图片的gt编码坐标信息 conf_t[idx] = conf # [num_priors] top class label for each prior 设置第idx张图片的编号信息.(大于0即为物体编号, 认为有物体, 小于0认为是背景) 参考文章：https://blog.csdn.net/happyday_d/article/details/86021993 https://hellozhaozheng.github.io/z_post/PyTorch-SSD]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>论文阅读</tag>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matplotlib绘制六种可视化图表]]></title>
    <url>%2F2019%2F08%2F24%2Fpythonplot%2F</url>
    <content type="text"><![CDATA[01 折线图1234567891011121314151617import numpy as np import matplotlib.pyplot as pltx = np.linspace(0,2,100)plt.plot(x, x, label='linear')plt.plot(x, x**2, label='quadratic')plt.plot(x, x**3, label='cubic')plt.xlabel('x label')plt.ylabel('y label')plt.title("Simple Plot")plt.legend()plt.show() 02 散点图12345678import numpy as npimport matplotlib.pyplot as pltx = np.arange(0., 5., 0.2)# 红色破折号, 蓝色方块 ，绿色三角块plt.plot(x, x, 'r--', x, x**2, 'bs', x, x**3, 'g^')plt.show() 03 直方图123456789101112131415161718192021222324252627282930import numpy as npimport matplotlib.pyplot as pltnp.random.seed(19680801)mu1, sigma1 = 100, 15mu2, sigma2 = 80, 15x1 = mu1 + sigma1 * np.random.randn(10000)x2 = mu2 + sigma2 * np.random.randn(10000)# the histogram of the data# 50：将数据分成50组# facecolor：颜色；alpha：透明度# density：是密度而不是具体数值n1, bins1, patches1 = plt.hist(x1, 50, density=True, facecolor='g', alpha=1)n2, bins2, patches2 = plt.hist(x2, 50, density=True, facecolor='r', alpha=0.2)# n：概率值；bins：具体数值；patches：直方图对象。plt.xlabel('Smarts')plt.ylabel('Probability')plt.title('Histogram of IQ')plt.text(110, .025, r'$\mu=100,\ \sigma=15$')plt.text(50, .025, r'$\mu=80,\ \sigma=15$')# 设置x，y轴的具体范围plt.axis([40, 160, 0, 0.03])plt.grid(True)plt.show() 04 柱状图4.1 并列柱状图123456789101112131415161718192021import numpy as npimport matplotlib.pyplot as pltsize = 5a = np.random.random(size)b = np.random.random(size)c = np.random.random(size)x = np.arange(size)# 有多少个类型，只需更改n即可total_width, n = 0.8, 3 width = total_width / n# 重新拟定x的坐标x = x - (total_width - width) / 2# 这里使用的是偏移plt.bar(x, a, width=width, label='a')plt.bar(x + width, b, width=width, label='b')plt.bar(x + 2 * width, c, width=width, label='c')plt.legend()plt.show() 4.2 叠加柱状图12345678910111213141516171819import numpy as npimport matplotlib.pyplot as pltsize = 5a = np.random.random(size)b = np.random.random(size)c = np.random.random(size)x = np.arange(size)# 这里使用的是偏移plt.bar(x, a, width=0.5, label='a',fc='r')plt.bar(x, b, bottom=a, width=0.5, label='b', fc='g')plt.bar(x, c, bottom=a+b, width=0.5, label='c', fc='b')plt.ylim(0, 2.5)plt.legend()plt.grid(True)plt.show() 05 饼图5.1 普通饼图123456789101112131415import matplotlib.pyplot as pltlabels = 'Frogs', 'Hogs', 'Dogs', 'Logs'sizes = [15, 30, 45, 10]# 设置分离的距离，0表示不分离explode = (0, 0.1, 0, 0) plt.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%', shadow=True, startangle=90)# Equal aspect ratio 保证画出的图是正圆形plt.axis('equal') plt.show() 5.2 嵌套饼图1234567891011121314151617181920212223242526import numpy as npimport matplotlib.pyplot as plt# 设置每环的宽度size = 0.3vals = np.array([[60., 32.], [37., 40.], [29., 10.]])# 通过get_cmap随机获取颜色cmap = plt.get_cmap("tab20c")outer_colors = cmap(np.arange(3)*4)inner_colors = cmap(np.array([1, 2, 5, 6, 9, 10]))print(vals.sum(axis=1))# [92. 77. 39.]plt.pie(vals.sum(axis=1), radius=1, colors=outer_colors, wedgeprops=dict(width=size, edgecolor='w'))print(vals.flatten())# [60. 32. 37. 40. 29. 10.]plt.pie(vals.flatten(), radius=1-size, colors=inner_colors, wedgeprops=dict(width=size, edgecolor='w'))# equal 使得为正圆plt.axis('equal') plt.show() 5.3 极轴饼图12345678910111213141516171819202122import numpy as npimport matplotlib.pyplot as pltnp.random.seed(19680801)N = 10theta = np.linspace(0.0, 2 * np.pi, N, endpoint=False)radii = 10 * np.random.rand(N)width = np.pi / 4 * np.random.rand(N)ax = plt.subplot(111, projection='polar')bars = ax.bar(theta, radii, width=width, bottom=0.0)# left表示从哪开始，# radii表示从中心点向边缘绘制的长度（半径）# width表示末端的弧长# 自定义颜色和不透明度for r, bar in zip(radii, bars): bar.set_facecolor(plt.cm.viridis(r / 10.)) bar.set_alpha(0.5)plt.show() 06 三维图6.1 绘制三维散点图1234567891011121314151617import numpy as npimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Ddata = np.random.randint(0, 255, size=[40, 40, 40])x, y, z = data[0], data[1], data[2]ax = plt.subplot(111, projection='3d') # 创建一个三维的绘图工程# 将数据点分成三部分画，在颜色上有区分度ax.scatter(x[:10], y[:10], z[:10], c='y') # 绘制数据点ax.scatter(x[10:20], y[10:20], z[10:20], c='r')ax.scatter(x[30:40], y[30:40], z[30:40], c='g')ax.set_zlabel('Z') # 坐标轴ax.set_ylabel('Y')ax.set_xlabel('X')plt.show() 6.2 绘制三维平面图12345678910111213141516from matplotlib import pyplot as pltimport numpy as npfrom mpl_toolkits.mplot3d import Axes3Dfig = plt.figure()ax = Axes3D(fig)X = np.arange(-4, 4, 0.25)Y = np.arange(-4, 4, 0.25)X, Y = np.meshgrid(X, Y)R = np.sqrt(X**2 + Y**2)Z = np.sin(R)# 具体函数方法可用 help(function) 查看，如：help(ax.plot_surface)ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap='rainbow')plt.show() 参考链接： https://mp.weixin.qq.com/s/bMvrle-FRvli0pRNi83waQ]]></content>
      <categories>
        <category>programs</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SqueezeNet]]></title>
    <url>%2F2019%2F08%2F20%2Fsqueezenet%2F</url>
    <content type="text"><![CDATA[论文地址: SqueezeNet: AlexNet-level accuracy with 50x fewer parameters and &lt;0.5MB model size非官方代码: pytorch 介绍这篇文章是DeepScal，加州大学伯克利分校，以及斯坦福大学在ICLR 2017发表的一篇文章。文章的主要目的是为了压缩模型，提高运行速度。这篇文章主要提出了SqueezeNet: 使用少量参数保持精度。 结构设计策略这篇文章的首要目标是在保持准确率 的同时，有几个参数的CNN架构。这篇文章在设计CNN架构的时候采取了三个主要策略。这篇文章的主要模块 是Fire模块。 用1x1的卷积核代替3x3的卷积核，从而减少参数量。1x1 卷积的参数比3x3的卷积核少了 9X. 减少3x3 卷积输入通道的数量。假设有一个卷积层, 它完全由3x3 卷积组成。此层中参数的总数量为：(输入通道数) (过滤器数) (3 * 3)。要在squeeze层中将输入的通道数减少。 在网络中减少下采样(maxpooling)实现, 以便卷积层具有较大的特征图。 Fire ModuleFire Module是将原来一层conv层变成两层：squeeze层+expand层，各自带上Relu激活层。在squeeze层里面全是1x1的卷积kernel，数量记为S11；在expand层里面有1x1和3x3的卷积kernel，expand层之后将1x1和3x3的卷积output feature maps在channel维度cat。 自己手推的一张图，字比较丑，也没时间重现写一下。 fire moudle的pytorch代码很奇怪的是论文中用的是3个1x1，以及expand用的是4个1x1的卷积核和4个 3x3的卷积核，但是pytroch版本的代码并没有体现出来。12345678910111213141516171819202122232425262728293031323334class fire(nn.Module): def __init__(self, inplanes,squeeze_planes, expand_planes): super(fire,self).__init__() self.conv1 = nn.Conv2d(inplanes,squeeze_planes, kernel_size=1, stride=1) self.bn1 = nn.BatchNorm2d(squeeze_planes) self.relu1 = nn.ReLU(inplace=True) self.conv2 = nn.Conv2d(squeeze_planes, expand_planes, kernel_size=1, stride=1) self.bn2 = nn.BatchNorm2d(expand_planes) self.conv3 = nn.Conv2d(squeeze_planes,expand_planes,kernel_size=3, stride=1,padding=1) self.bn3 = nn.BatchNorm2d(expand_planes) self.relu2 = nn.ReLU(inplace=True) # using MSR initialization for m in self.modules(): if isinstance(m,nn.Conv2d): n = m.kernel_size[0]*m.kernel_size[1]*m.in_channels m.weight.data.normal_(0,math.sqrt(2./n)) def forward(self,x): x = self.conv1(x) x = self.bn1(x) x = self.relu1(x) out1 = self.conv2(x) out1 = self.bn2(out1) out2 = self.conv3(x) out2 = self.bn3(out2) out = torch.cat([out1,out2],1) out = self.relu2(out) return out SqueezeNet的具体网络结构 实验结果imagenet数据上比较了alexnet，可以看到准确率差不多的情况下，squeezeNet模型参数数量显著降低了（下表倒数第三行），参数减少50X；如果再加上deep compression技术，压缩比可以达到461X！还是不错的结果。 参考文章：https://blog.csdn.net/xbinworld/article/details/50897870]]></content>
      <categories>
        <category>轻量级网络</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>论文阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治算法]]></title>
    <url>%2F2019%2F08%2F19%2F%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[问题： 给定一组数，要求从中找出第k小的元素。分析：这里通过快速排序算法来解决次问题。记一趟快速排序后，左子集中的元素个数为nleft，则选择问题，可能是一下几种情况之一： nleft等于k-1，则枢纽值即为所求； nleft大于k-1,则继续在左子树中找； nleft小于k-1,则继续在右子集中找C++代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344// t5.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &quot;stdafx.h&quot;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;int quickSelect(int a[], int l, int r, int k)&#123; int p = rand() % (r - l + 1) + l; int pivot = a[p]; &#123;int t = a[p]; a[p] = a[r]; a[r] = t; &#125; int i = l,j = r; while (i &lt; j) &#123; while (i &lt; j&amp;&amp;a[i] &lt; pivot) i++; if (i &lt; j) &#123; a[j] = a[i]; j--; &#125; while (i &lt; j&amp;&amp;a[i] &gt;pivot) j--; if (i &lt; j) &#123; a[i] = a[j]; i++; &#125; &#125; a[i] = pivot; p = i; if (i - l + 1 == k) return a[i]; // j + 1, right, k - (j - left + 1)1) if (i - l + 1 &lt; k) return quickSelect(a, i+1, r, k-i+l-1); else return quickSelect(a, l, i-1, k);&#125;int main()&#123; int a[] = &#123; 1,4,54,8,3,7,45,58,27,8,25,26,21,12 &#125;; printf_s(&quot;%d\n&quot;, quickSelect(a, 0, 14, 6)); system(&quot;pause&quot;); return 0;&#125;]]></content>
      <categories>
        <category>programs</category>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MobileNetsV2]]></title>
    <url>%2F2019%2F08%2F19%2FMobileNetsV2%2F</url>
    <content type="text"><![CDATA[论文地址:MobileNetV2: Inverted Residuals and Linear Bottlenecks 非官方代码:pytorch 介绍这篇文章是谷歌在2019提出来的文章在MobileNets 基础上做的改进。 深度可分离卷积示例 首先在Xception 中被广泛使用 好处： 理论上可以成倍的减少卷积层的时间复杂度和空间复杂度 文章内容与MobileNets 的对比 相同点 都采用 Depth-wise (DW) 卷积搭配 Point-wise (PW) 卷积的方式来提特征 不同点 Linear Bottleneck V2 在 DW 卷积之前新加了一个 PW 卷积。 DW卷积由于本身的计算特性不能改变通道数的能力。若通道数很少的话，DW在提取地低纬特征，效果可能并不会好。 在每个DW之前，增加了PW用于升维，这样DW可以更好的提取特征 V2 去掉了第二个 PW 的激活函数 激活函数在高维空间能够有效的增加非线性，而在低维空间时则会破坏特征 第二个 PW 的主要功能就是降维 与ResNet的对比 相同点 MobileNet V2 借鉴 ResNet，都采用了 1x1-&gt;3x3-&gt;1x1的模式 MobileNet V2 借鉴 ResNet，同样使用 Shortcut 将输出与输入相加 不同点 Inverted Residual Block ResNet 使用 标准卷积 提特征，MobileNet 始终使用 DW卷积 提特征 ResNet 先降维 (0.25倍)、卷积、再升维，而 MobileNet V2 则是 先升维 (6倍)、卷积、再降维。直观的形象上来看，ResNet 的微结构是沙漏形，而 MobileNet V2 则是纺锤形，刚好相反。因此论文作者将 MobileNet V2 的结构称为 Inverted Residual Block。使用DW卷积而作的适配，特征提取能够在高维进行 结论 MobileNets 与MobileNets V2在模型结构上的对比 MobileNetsV2 的卷积层数比V1要多，但是时间复杂度，以及空间复杂度，以及在cpu上的推理时间要远远优于MobileNets 参考文章：https://zhuanlan.zhihu.com/p/33075914]]></content>
      <categories>
        <category>轻量级网络</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>论文阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MobileNets]]></title>
    <url>%2F2019%2F08%2F19%2FMobileNets%2F</url>
    <content type="text"><![CDATA[论文地址:MobileNets: Efficient Convolutional Neural Networks for Mobile Vision Applications 非官方代码:pytorch/models 前言这篇文章是谷歌在2017针对手机等嵌入式设备提出的一种轻量级深层网络，这篇论文主要的贡献点在于提出了一种深度可分离卷积。 主要解决的问题是注重优化延迟，同时也兼顾了模型的大小，不像有些模型虽然参数量比较小，但是速度也是慢的可以。 MobileNets使用了大量的3 × 3的卷积核，极大地减少了计算量（1/8到1/9之间），同时准确率下降的很少，相比其他的方法确有优势。 深度可分离卷积示例 模型结构和训练MobileNets结构建立在上述深度可分解卷积中（只有第一层是标准卷积）。该网络允许我们探索网络拓扑，找到一个适合的良好网络。其具体架构在表1说明。除了最后的全连接层，所有层后面跟了batchnorm和ReLU，最终输入到softmax进行分类。图3对比了标准卷积和分解卷积的结构，二者都附带了BN和ReLU层。按照作者的计算方法，MobileNets总共28层（1 + 2 × 13 + 1 = 28）]]></content>
      <categories>
        <category>轻量级网络</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>论文阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多层感知机的反向传播]]></title>
    <url>%2F2019%2F08%2F19%2FMLP-Back-Propagation%2F</url>
    <content type="text"><![CDATA[全连接神经网络是形式上最简单的神经网络，反向传播算法是一种常用的训练神经网络的算法，理解全连接神经网络中的反向传播算法是理解其他更加复杂网络中反向传播算法的重要基础。 参考链接： https://zhuanlan.zhihu.com/p/61863634]]></content>
      <categories>
        <category>Math</category>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典第四章]]></title>
    <url>%2F2019%2F08%2F18%2Falgorithm4%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157// t4.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;//素数判断方法2#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;#define Max 1000000#define maxn 100int left, chance; //还需要left位置，错chance之后就会输char s[maxn], s2[maxn]; //答案是字符串s, 玩家猜的字母序列是s2int win, lose; // win=1 表示已经赢了; lose=1 表示已经输了long fac(int n) &#123; if (0 == n || 1 == n) &#123; return 1; &#125; else &#123; return fac(n - 1)*n; &#125;&#125;// 非递归的阶乘方法 long fact(int n)&#123; long iRes = 1; for (int i = 1; i &lt;= n; i++) &#123; iRes *= i; &#125; return iRes;&#125;int combination(int m, int n)&#123; long iRes = fac(n) / (fac(m)*fac(n - m)); // long iRes = fact(n) /(fac(m)*fac(n-m)); printf_s(&quot;%ld %.2lf \n&quot;, iRes, (double)clock() / CLOCKS_PER_SEC); return iRes;&#125;// 刽子手游戏---guess函数void guess(char ch)&#123; int bad = 1; for (int i = 0; i &lt; strlen(s); i++) if (s[i] == ch) &#123; left--; s[i] = &apos; &apos;; bad = 0; &#125; if (bad) --chance; if (!chance) lose = 1; if (!left) win = 1;&#125;int main()&#123; /* 关键: 1 用素数筛选法先预处理，默认刚开始全为素数，然后对素数的倍数标记为非素数， for(int j = i*i ; j &lt;= 10000 ; j += i)&#123;iPrimeArr[j] = 1;&#125; 2 通过开根号判断素数时，可以用floor,注意浮点数加上0.5，int iRadical = floor(sqrt(n*1.0) + 0.5); 3 可以用assert()对输入的合法性进行校验，assert(n &gt;= 5 &amp;&amp; n &lt;= 10000);void assert(int exp),如果表达式的值为0则退出。*/ //int sum = 1; //for (int i = 3; i &lt;= Max; i += 2) //&#123; // //因为偶数除了2 都不是质数 // int j; // for (j = 2; j &lt;= (int)sqrt(i); j++)//利用上述结论判断 // if (i%j == 0) break; // if (j &gt; (int)sqrt(i)) // sum++; //&#125; //printf_s(&quot;Time used = %0.2f s\n&quot;, (double)clock() / CLOCKS_PER_SEC); //printf_s(&quot;%d\n&quot;, sum); //int a, b; //scanf_s(&quot;%d %d&quot;, &amp;a, &amp;b); //combination(a, b); //刽子手游戏 /* 游戏规则是这样的：计算机想一个单词让你猜，你每次可以猜一个字母。 如果单词里有那个字母，所有该字母会显示出来；如果没有那个字母，则计算机会在一幅“刽子手”画上填一笔。 这幅画一共需要7笔就能完成，因此你最多只能错6次。 注意，猜一个已经猜过的字母也算错。 在本题中，你的任务是编写一个“裁判”程序，输入单词和玩家的猜测，判断玩家赢了（You win.）、 输了（You lose.）还是放弃了（You chickened out.）。 每组数据包含3行，第1行是游戏编号（-1为输入结束标记），第2行是计算机想的单词，第3行是玩家的猜测。 后两行保证只含小写字母。 */ //char ans[21]; //char gus[28]; //int times, yes; //int chances = 7; //int win = 0; //int lose = 0; //scanf_s(&quot;%d&quot;, &amp;times); //while (times != -1) //&#123; // printf_s(&quot;Round %d\n&quot;, times); // scanf_s(&quot;%s\n %s&quot;, ans, gus); // printf_s(&quot;Round %s &amp;s\n&quot;, ans, gus); // yes = 0; // win = 0, lose = 0, chances = 7; // for (int i = 0; i &lt; strlen(gus); i++) // &#123; // int flag = 0; // for (int j = 0; j &lt; strlen(ans); j++) // &#123; // if (ans[j] == gus[i]) // &#123; // yes++; // flag = 1;//找到之后不退出，因为有一个有相同的字母 // &#125; // if (flag == 0) // &#123; // chances--; // &#125; // if (chances == 0) // &#123; // lose = 1; // printf_s(&quot;You lose.\n&quot;); // &#125; // else if (yes == strlen(ans)) // &#123; // win = 1; // printf_s(&quot;You win.\n&quot;); // break; // &#125; // if (win != 1 &amp;&amp; lose != 1) // &#123; // printf(&quot;You chickened out.\n&quot;); // &#125; // scanf_s(&quot;%d&quot;, &amp;times); // &#125; // &#125; //&#125; int rnd; while (scanf_s(&quot;%d%s%s&quot;, &amp;rnd, &amp;s, &amp;s2) == 3 &amp;&amp; rnd != -1) &#123; printf_s(&quot;%Round %d\n&quot;, rnd); win = lose = 0; left = strlen(s); chance = 7; for (int i = 0; i &lt; strlen(s2); i++) &#123; guess(s2[i]); //猜一个字母 if (win || lose) break; //检查状态 &#125; //根据结果进行输出 if (win) printf_s(&quot;You win.\n&quot;); else if (lose) printf_s(&quot;You lose.\n&quot;); else printf_s(&quot;You chickened out.\n&quot;); &#125; system(&quot;pause&quot;); return 0;&#125;]]></content>
      <categories>
        <category>programs</category>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典第三章]]></title>
    <url>%2F2019%2F08%2F16%2Falgorithm3%2F</url>
    <content type="text"><![CDATA[今天心情不好，所以就敲了这一点代码，希望明天的状态能好一点！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// t3.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &quot;stdio.h&quot;#include &lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;#define maxn 10000000 +10char s[maxn];int main()&#123; //题目1 统计个数 /*int count =0; int temp; while (~scanf_s(&quot;%d&quot;, &amp;temp)) &#123; count++; &#125; printf_s(&quot;%d&quot;, count);*/ //显示不出来 //输入一些数，求最大值、最小值和平均数 //int min, max, n, sum,count = 0; //float avg; //scanf_s(&quot;%d&quot;, &amp;n); //max = n; //min = n; //sum = n; //count++; //while (scanf_s(&quot;%d&quot;, &amp;n)!=EOF) //&#123; // count++; // sum += n; // if (n &gt; max) // max = n; // if (n &lt; min) // min = n; //&#125; //avg = sum*1.0 / count; //printf_s(&quot;%d %d %f\n&quot;, max,min,avg); //5.输入一些数 ，求出他们的方差 /*double ave, sum = 0, varance, psum = 0; int n.a[110], count = 0; while (scanf_s(&quot;%d&quot;, &amp;n) != EOF) &#123; a[count++] = n; sum += n; &#125; avg = sum*1.0 / count; for (int i = 0; i &lt; count; i++) psum += (a[i] - ave)*(a[i] - ave); variance = psum / count; print(&quot;%lf&quot;, variance);*/ scanf_s(&quot;%s&quot;, s); int tot = 0; for (int i = 0;s[i]; i++) &#123; if (s[i] == &apos;1&apos;) tot++; &#125; printf_s(&quot;%d\n&quot;, tot); system(&quot;pause&quot;); return 0;&#125;]]></content>
      <categories>
        <category>programs</category>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LNMS]]></title>
    <url>%2F2019%2F08%2F16%2FLNMS%2F</url>
    <content type="text"><![CDATA[locality NMSLNMS是在EAST文本检测中提出的．主要原因：文本检测面临的是成千上万个几何体，如果用普通的NMS，其计算复杂度，n是几何体的个数，这是不可接受的．对上述时间复杂度问题，EAST提出了基于行合并几何体的方法，当然这是基于邻近几个几何体是高度相关的假设．注意：这里合并的四边形坐标是通过两个给定四边形的得分进行加权平均的，也就是说这里是“平均”而不是”选择”几何体*,目的是减少计算量．基本步骤1.先对所有的output box集合结合相应的阈值（大于阈值则进行合并，小于阈值则不和并），依次遍历进行加权合并，得到合并后的bbox集合；2.对合并后的bbox集合进行标准的NMS操作1234567891011121314151617181920212223242526272829303132333435363738394041424344def detect(score_map, geo_map, timer, score_map_thresh=1e-5, box_thresh=1e-8, nms_thres=0.1): &apos;&apos;&apos; restore text boxes from score map and geo map :param score_map: bs* 128 * 128 * 1 :param geo_map: ## geo_map = bs * 128 * 128 * 5 :param timer: :param score_map_thresh: threshhold for score map :param box_thresh: threshhold for boxes :param nms_thres: threshold for nms :return: &apos;&apos;&apos; if len(score_map.shape) == 4: score_map = score_map[0, :, :, 0] geo_map = geo_map[0, :, :, ] # filter the score map xy_text = np.argwhere(score_map &gt; score_map_thresh) # sort the text boxes via the y axis xy_text = xy_text[np.argsort(xy_text[:, 0])] # restore start = time.time() text_box_restored = restore_rectangle(xy_text[:, ::-1]*4, geo_map[xy_text[:, 0], xy_text[:, 1], :]) # N*4*2 #print(&apos;&#123;&#125; text boxes before nms&apos;.format(text_box_restored.shape[0])) boxes = np.zeros((text_box_restored.shape[0], 9), dtype=np.float32) boxes[:, :8] = text_box_restored.reshape((-1, 8)) boxes[:, 8] = score_map[xy_text[:, 0], xy_text[:, 1]] timer[&apos;restore&apos;] = time.time() - start # 得到box 的坐标以及分数 # nms part start = time.time() # boxes = nms_locality.nms_locality(boxes.astype(np.float64), nms_thres) boxes = lanms.merge_quadrangle_n9(boxes.astype(&apos;float32&apos;), nms_thres) timer[&apos;nms&apos;] = time.time() - start if boxes.shape[0] == 0: return None, timer # here we filter some low score boxes by the average score map, this is different from the orginal paper for i, box in enumerate(boxes): mask = np.zeros_like(score_map, dtype=np.uint8) cv2.fillPoly(mask, box[:8].reshape((-1, 4, 2)).astype(np.int32) // 4, 1) boxes[i, 8] = cv2.mean(score_map, mask)[0] boxes = boxes[boxes[:, 8] &gt; box_thresh] return boxes, timer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import numpy as npfrom shapely.geometry import Polygondef intersection(g, p): #取g,p中的几何体信息组成多边形 g = Polygon(g[:8].reshape((4, 2))) p = Polygon(p[:8].reshape((4, 2))) # 判断g,p是否为有效的多边形几何体 if not g.is_valid or not p.is_valid: return 0 # 取两个几何体的交集和并集 inter = Polygon(g).intersection(Polygon(p)).area union = g.area + p.area - inter if union == 0: return 0 else: return inter/uniondef weighted_merge(g, p): # 取g,p两个几何体的加权（权重根据对应的检测得分计算得到） g[:8] = (g[8] * g[:8] + p[8] * p[:8])/(g[8] + p[8]) #合并后的几何体的得分为两个几何体得分的总和 g[8] = (g[8] + p[8]) return gdef standard_nms(S, thres): #标准NMS order = np.argsort(S[:, 8])[::-1] keep = [] while order.size &gt; 0: i = order[0] keep.append(i) ovr = np.array([intersection(S[i], S[t]) for t in order[1:]]) inds = np.where(ovr &lt;= thres)[0] order = order[inds+1] return S[keep]def nms_locality(polys, thres=0.3): &apos;&apos;&apos; locality aware nms of EAST :param polys: a N*9 numpy array. first 8 coordinates, then prob :return: boxes after nms &apos;&apos;&apos; S = [] #合并后的几何体集合 p = None #合并后的几何体 for g in polys: if p is not None and intersection(g, p) &gt; thres: #若两个几何体的相交面积大于指定的阈值，则进行合并 p = weighted_merge(g, p) else: #反之，则保留当前的几何体 if p is not None: S.append(p) p = g if p is not None: S.append(p) if len(S) == 0: return np.array([]) return standard_nms(np.array(S), thres)if __name__ == &apos;__main__&apos;: # 343,350,448,135,474,143,369,359 print(Polygon(np.array([[343, 350], [448, 135], [474, 143], [369, 359]])).area) 参考博客： https://www.jianshu.com/p/4934875f7eb6]]></content>
      <categories>
        <category>programs</category>
        <category>algorithm</category>
        <category>cv</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>nms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典第二章]]></title>
    <url>%2F2019%2F08%2F15%2Falgorithm2%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187// t2.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &quot;stdio.h&quot;#include &lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;int main()&#123; ////3n+1问题、 //int n, count = 0; //当n过大的时候 2*n溢出 // //scanf_s(&quot;%d&quot;, &amp;n); //long long n2 = n; //while (n2 &gt; 1) //&#123; // if (n2 % 2 == 1) n2 = n2 * 3 + 1; // else n2 /= 2; // count++; //&#125; //printf_s(&quot;%d\n&quot;, count); //近似计算 /*double sum = 0; for (int i = 0;; i++) &#123; double term = 1.0 / (i * 2 + 1); if (i % 2 == 0) sum += term; else sum -= term; if (term &lt; 1e-6) break; &#125; printf_s(&quot;%.6f\n&quot;, sum);*/ // 阶乘之和 只保存后六位 //int n, S = 0; //scanf_s(&quot;%d&quot;, &amp;n); //for (int i = 1; i &lt;= n; i++) //&#123; // int factorial = 1; // for (int j = 1; j &lt;= i; j++) // factorial *= j; // S += factorial; //&#125; //printf_s(&quot;%d\n&quot;, S % 1000000); // 阶乘之和2, 优化版本 //int n, S = 0; //const int MOD = 1000000; //scanf_s(&quot;%d&quot;, &amp;n); //for (int i = 1; i &lt;= n; i++) //&#123; // int factorial = 1; // for (int j = 1; j &lt;= i; j++) // factorial = (factorial *j)%MOD; // S += factorial; //&#125; //printf_s(&quot;%d\n&quot;, S %MOD); //printf_s(&quot;Time used = %.2f\n&quot;, (double)clock() / CLOCKS_PER_SEC); // 得到程序运行的时间 单位：秒 // 数据统计 //习题2.1 水仙花数目 /*int sum; for (int i = 1; i &lt; 10; i++) for (int k = 0; k &lt; 10; k++) for (int j = 0; j &lt; 10; j++) &#123; sum = i * 100 + 10 * k + j; if(sum == i*i*i+j*j*j + k*k*k) printf_s(&quot;%d &quot;, sum); &#125;*/ //习题2.2 韩信点兵 相传韩信才智过人，从不直接清点自己军队的人数，只要让士兵先后以三人一排、五人一排、七人一排地变换队形， //而他每次只掠一眼队伍的排尾就知道总人数了。输入包含多组数据，每组数据包含3个非负整数a，b，c，表示每种队形排尾的人数（a＜3，b＜5，c＜7）， //输出总人数的最小值（或报告无解）。已知总人数不小于10，不超过100。输入到文件结束为止。 //int i, a, b, c; //scanf_s(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); //for (i = 0; i &lt;= 100; i++) &#123; // if (i % 3 == a &amp;&amp; i % 5 == b &amp;&amp; i % 7 == c) // printf_s(&quot;%d\n&quot;, i); // //&#125; //if (i % 3 != a &amp;&amp; i % 5 != b &amp;&amp; i % 7 != c &amp;&amp; i&gt;100) // printf_s(&quot;No answer\n&quot;); //习题2.3 倒三角形 //int n, /* 输出n行; n&lt;=20 */ // i, /* 打印第i行 */ // j; //scanf_s(&quot;%d&quot;, &amp;n); //for (i = 1; i &lt;= n; i = i + 1) &#123; // /* 在第i行，打印(i-1)个空格 */ // for (j = 1; j &lt;= i - 1; j = j + 1) printf_s(&quot; &quot;); // /* 在第i行，打印(2*n-2*i+1)个# */ // for (j = 1; j &lt;= (2 * n - 2 * i + 1); j = j + 1) printf_s(&quot;#&quot;); // printf_s(&quot;\n&quot;); /* 输出结束后换行，否则所有的#号在同一行输出 */ //&#125; //习题2.4 子序列的和 输入两个正整数n＜m＜10 6 ，输出 ，保留5位小数。输入包含多组数据， 注：陷阱就是在n特别大时如果直接n*n就会溢出，所以只能连除两次 //int count = 0; //while (1) &#123; // int n = 0; // int m = 0; // scanf_s(&quot;%d&quot;, &amp;n); // scanf_s(&quot;%d&quot;, &amp;m); // if (n == m&amp;&amp;n == 0) &#123; // break; // &#125; // count++; // double sum = 0; // for (int i = n; i &lt;= m; i++) &#123; // sum += 1.0 / i / i; // &#125; // printf_s(&quot;Case %d:%.5f\n&quot;, count, sum); //&#125; //习题2.5 分数化小数（decimal） //输入正整数a，b，c，输出a / b的小数形式，精确到小数点后c位。a，b≤10 ^ 6，c≤100。输入包含多组数据，结束标记为a＝b＝c＝0。 // int count = 0; //while (1) &#123; // int a, b, c; // int k, d, i; // scanf_s(&quot;%d&quot;, &amp;a); // scanf_s(&quot;%d&quot;, &amp;b); // scanf_s(&quot;%d&quot;, &amp;c); // if (a == 0&amp;&amp;b == 0 &amp;&amp;c==0 ) &#123; // break; // &#125; // count++; // for (i = 0; i&lt;c - 1; i++) // &#123; // /*机智地把余数放大十倍，使之除以b并取模*/ // k = (k%b) * 10; // printf_s(&quot;Case %d:%.5f\n&quot;, count, k / b); // &#125; // k = (k%b) * 10; // d = (k%b) * 10 / b; // if (d &gt;= 5)//判断第c+1位小数是否大于等于5，if yes,第c位小数要进1 // &#123; // printf_s(&quot;Case %d:%.5f\n&quot;, count, k / b + 1); // &#125; // else // &#123; // printf_s(&quot;Case %d:%.5f\n&quot;, count, k / b); // &#125; // //&#125; int abc,def,ghi; int a[10],count=0; memset(a,0,sizeof(a)); // 将a数组中的值全部设置为0 for (abc = 123;abc &lt; 333;abc ++) &#123; // 基本可以确定abc的最小值和最大值 def = 2 * abc; ghi = 3 * abc; // 设置数组中所有对应的9位数字位置的值1 a[abc/100] = 1; // a a[abc/10%10] = 1; // b a[abc%10] = 1; // c a[def/100] = 1; // d a[def/10%10] = 1; // e a[def%10] = 1; // f a[ghi/100] = 1; // g a[ghi/10%10] = 1; // h a[ghi%10] = 1; // i int i; for (i=1;i&lt;=9;i++) &#123; count += a[i]; &#125; if (count == 9) &#123; printf_s(&quot;%d %d %d\n&quot;,abc,def,ghi); &#125; // 重置count 和a数组 count = 0; memset(a,0,sizeof(a)); &#125; system(&quot;pause&quot;); return 0; &#125;]]></content>
      <categories>
        <category>programs</category>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典第一章]]></title>
    <url>%2F2019%2F08%2F14%2Falgorithm1%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// t1.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &quot;stdio.h&quot;#include &lt;stdlib.h&gt;#include&lt;math.h&gt; int main()&#123; //printf(&quot;%.1f\n&quot;, 8.0 / 5.0); // %点后面是保留几位浮点小数1.6 //printf(&quot;%.1f\n&quot;, 8 / 5); // %点后面是保留几位浮点小数 结果为0 //printf(&quot;%d\n&quot;, 8.0 / 5.0); // 整数值用%d输出，实数用%f输出 # int 是2字节 ，float是4字节 溢出 // //整数/整数等与整数，浮点数除以浮点数等于浮点数 //printf(&quot;%.8f\n&quot;, 1 + 2 * sqrt(3) / (5 - 0.1)); //int a, b; //scanf_s(&quot;%d%d&quot;, &amp;a, &amp;b); //scanf_s 中的占位符要和变量的数据类型一一对应，要在变量前面加上“&amp;”符号 //printf(&quot;%d\n&quot;, a+b); //const double pi = acos(-1.0); //double r, h, s1, s2, s; //scanf_s(&quot;%1f%1f&quot;, &amp;r, &amp;h); //s1 = pi*r*r; //s2 = 2 * pi*r*h; //s = s1*2.0 + s2; //printf_s(&quot;Area = %.3f\n&quot;, s); //交换变量 //int a, b, m, n; //scanf_s(&quot;%d%d&quot;, &amp;a, &amp;b); ///*a = a + b; //b = a - b; //a = a - b;*/ //printf_s(&quot;%d %d\n&quot;, b, a); //int a, b, m, n; //scanf_s(&quot;%d%d&quot;, &amp;n, &amp;m); ///*a = a + b; //b = a - b; //a = a - b;*/ //a = (4*n-m) / 2; //b = n - a; //if (m % 2 == 1 || a &lt; 0 || b &lt; 0) // printf_s(&quot;No answer!\n&quot;); //else // printf_s(&quot;Answer is chicken %d rabbit %d\n&quot;, a, b); //exp1 输入三个整数，求出他们的平均数，保留三位小数 //int a, b, c; //scanf_s(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); //printf_s(&quot;%.3f&quot;, (a + b + c) / 3.0); //exp2 输入华氏温度f,输出对应的摄氏温度c,保留3位小数.提示 : c = 5(f-32)/9. //float f, c; //scanf_s(&quot;%f&quot;, &amp;f); //c = 5*(f - 32) / 9.0; //printf_s(&quot;摄制温度为： %.3f&quot;, c); //exp3 //int n; //scanf_s(&quot;%d&quot;, &amp;n); //printf_s(&quot;%d&quot;, n*(n + 1) / 2); //exp4 输入正整数《360 ，输出正弦余弦函数值。提示：使用数学函数 //int n; // #define PI 3.1415926 //scanf_s(&quot;%d&quot;, &amp;n); //if (n &lt; 0 || n&gt;360) // printf_s(&quot;error&quot;); //else //&#123; // printf_s(&quot;%.2f\n&quot;, cos(n*PI/180)); // printf_s(&quot;%.2f&quot;, sin(n*PI / 180)); //&#125; // // exp5 一件衣服95元，若消费满300元可以打85折，输入购买衣服的简书，输出需要支付的金额。保留两位小数 //int n,money; //scanf_s(&quot;%d&quot;, &amp;n); //money = n * 95; //if (money &gt; 300) // printf_s(&quot;%.2f&quot;, money* 0.85); //else // printf_s(&quot;%.2f&quot;, money); // //exp6 判断三个边是否能构成直角三角形 边长均为正整数 //int a, b, c; //scanf_s(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); //if (((a*a + b*b)== c*c) || ((a*a + c*c) == b*b) || ((c*c + b*b) == a*a)) // printf_s(&quot;yes\n&quot;); //else // printf_s(&quot;not a triangle\n&quot;); //exp7 判断一个年是不是闰年 能被4整除但是不能被100整除的年份 //int n; //scanf_s(&quot;%d&quot;, &amp;n); //if (n % 4 == 0 &amp;&amp; n % 100 != 0) // printf_s(&quot;yes\n&quot;); //else // printf_s(&quot;no\n&quot;); // //q1: int类型的最大值和最小值是多少 2^(n - 1) - 1 -2^(n - 1) //q2; double浮点数能精确到多少位小数？ 遵循IEEE标准的8字节（64位）的double能表示的有效数字的位数是：15 ~ 16 //q3: double类型的最大正数值和最小正数值 //q4: 逻辑运算符号的优先级 system(&quot;pause&quot;); return 0;&#125; 思考题解析： https://blog.csdn.net/panderang/article/details/54096426]]></content>
      <categories>
        <category>programs</category>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F07%2F29%2F%E6%96%87%E6%9C%AC%E6%A3%80%E6%B5%8B%E8%B0%83%E7%A0%94%2F</url>
    <content type="text"><![CDATA[文本检测问题，广义上来说可以看做是一个目标检测的问题，但是相当于目标检测要简单的多。因为目标检测往往除了背景还有其他的类，而文本检测，只需要检测背景和文本类两个问题。因此可以采用目标检测或者分割的方法来进行文本检测。而视频中的文本检测，也可以看做是视频中的目标检测中的一种，感觉应该也可以用视频中的目标检测+跟踪来做。 通常目标跟踪面临的极大难点：物体变形、亮度变化、快速移动、背景干扰覆盖。其中最主要的三个难题分别是目标背景的变化，物体本身的变化，光照强度的变化。 光流法帧间差分法背景差分法]]></content>
  </entry>
  <entry>
    <title><![CDATA[c++中级教程 顺序容器的定义]]></title>
    <url>%2F2019%2F07%2F26%2F%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[顺序容器的定义 顺序容器 vector list deque 顺序容器适配器 stack queue priority_queue]]></content>
      <categories>
        <category>programs</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++中级教程 STL queue]]></title>
    <url>%2F2019%2F07%2F26%2FSTLqueue%2F</url>
    <content type="text"><![CDATA[STL queue 队列： FIFO 先进先出 自适应容器（容器适配器） 栈适配器 STL queue12345678queue&lt;int, deque&lt;int&gt;&gt; q;queue&lt;int, list&lt;int&gt;&gt; q;q.empty()q.size()q.front()q.back()q.pop()q.push(item) 可以用list和deque做queue先进先出，后进后出12345678910111213141516171819202122232425262728293031323334353637383940// queue.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;list&gt;#include&lt;deque&gt;using namespace std;int main()&#123; queue&lt;int, deque&lt;int&gt;&gt; a; queue&lt;int, list&lt;int&gt;&gt; b; //queue&lt;int, vector&lt;int&gt;&gt; c; 不可以，因为vector不能进行两端操作 //队列有什么用途？？？ queue&lt;int&gt; q; q.push(10); q.push(5); q.push(-1); q.push(20); cout &lt;&lt; "现在队列里有" &lt;&lt; q.size() &lt;&lt; "个数据 " &lt;&lt; endl; cout &lt;&lt; "队首的数据：" &lt;&lt; q.front() &lt;&lt; endl; cout &lt;&lt; "队尾的数据：" &lt;&lt; q.back() &lt;&lt; endl; q.pop(); cout &lt;&lt; "新的队首的数据：" &lt;&lt; q.front() &lt;&lt; endl; while (q.size() != 0) &#123; cout &lt;&lt; " 删除" &lt;&lt; a.front() &lt;&lt; endl; q.pop(); &#125; if (q.empty()) &#123; cout &lt;&lt; "队列为空！"&lt;&lt;endl; &#125; system("pause"); return 0;&#125; 优先级队列 priority_queue 自适应容器（容器适配器）：不能使用list 最大值优先级队列、最小值优先级队列(值越大，优先级越高，值越小优先级越高) 优先级队列适配器 STL priority_queue 1234567891011priority_queue&lt;int, deque&lt;int&gt;&gt; pg1;//对队列里的数据进行随机操作，所以不能使用listpriority_queue&lt;int, vector&lt;int&gt;&gt; pg2; //vector是默认的 //谓词priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; pg2; //vector是默认的，最小优先队列pg.empty()pg.size()pg.top()pg.pop()pg.push(item)~~~~~~~~~~ 1234567891011121314151617181920212223242526272829303132333435363738394041// priority_queue.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include&lt;iostream&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;int main()&#123; priority_queue&lt;int, deque&lt;int&gt;&gt; pg1; //对队列里的数据进行随机操作，所以不能使用list priority_queue&lt;int, vector&lt;int&gt;&gt; pg2; //vector是默认的 //谓词 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; pg2; //vector是默认的，最小优先队列 pg2.push(10); pg2.push(5); pg2.push(-1); pg2.push(20); cout &lt;&lt; &quot;优先级队列一共有： &quot; &lt;&lt; pg2.size() &lt;&lt; &quot;个数据&quot; &lt;&lt; endl; cout &lt;&lt; pg2.top() &lt;&lt; endl; while (!pg2.empty()) &#123; cout &lt;&lt; &quot;从优先级队列里删除： &quot; &lt;&lt; pg2.top() &lt;&lt; endl; pg2.pop(); &#125; system(&quot;pause&quot;); return 0;&#125;优先级队列一共有： 4个数据20从优先级队列里删除： 20从优先级队列里删除： 10从优先级队列里删除： 5从优先级队列里删除： -1请按任意键继续. . .~~]]></content>
      <categories>
        <category>programs</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[firstblog]]></title>
    <url>%2F2019%2F07%2F25%2Ffirstblog%2F</url>
    <content type="text"><![CDATA[以上是摘要 Hello World]]></content>
      <categories>
        <category>dailylife</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++中级教程(一)]]></title>
    <url>%2F2019%2F07%2F25%2F%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8-STL-deque-%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[顺序容器 STL deque 类 deque是一个动态数组 deque与vector 非常类似 deque可以在数组开头和末尾插入和删除数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// demo3.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include &lt;iostream&gt;#include &lt;deque&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; deque&lt;int&gt; a; a.push_back(3); a.push_back(4); a.push_back(5); a.push_back(6); //vector只能push_back a.push_front(2); a.push_front(1); a.push_front(9); a.push_front(8); for (size_t nCount = 0; nCount &lt; a.size(); ++nCount) &#123; cout &lt;&lt;"a["&lt;&lt;nCount&lt;&lt;"]" &lt;&lt; "= " &lt;&lt; a[nCount] &lt;&lt; endl; &#125; cout &lt;&lt; endl&lt;&lt;endl; a.pop_front();// 前面删除 a.pop_back();// 后面删除 cout &lt;&lt; "删除之后：" &lt;&lt; endl; /*for (size_t nCount = 0; nCount &lt; a.size(); ++nCount) &#123; cout &lt;&lt; "a[" &lt;&lt; nCount &lt;&lt; "]" &lt;&lt; a[nCount] &lt;&lt; endl; &#125;*/ deque&lt;int&gt;::iterator iElementLocater; //这边使用了迭代器 distence 可以计算当前 for (iElementLocater = a.begin(); iElementLocater != a.end(); ++iElementLocater) &#123; size_t nOffset = distance(a.begin(), iElementLocater);//distence 可以计算当前下标与begin开始的，距离正好是下标 cout &lt;&lt; "a[" &lt;&lt; nOffset &lt;&lt; "]" &lt;&lt; "= "&lt;&lt;*iElementLocater &lt;&lt; endl; &#125; system("pause"); return 0;&#125;a[0]= 8a[1]= 9a[2]= 1a[3]= 2a[4]= 3a[5]= 4a[6]= 5a[7]= 6删除之后：a[0]= 9a[1]= 1a[2]= 2a[3]= 3a[4]= 4a[5]= 5请按任意键继续. . . 順序容器 STL list 類 实例化std::list对象 在list开头插入元素 在list末尾插入元素 在list中间插入元素 删除list中的元素 对list中的元素进行反转和排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// list.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include&lt;iostream&gt;#include&lt;list&gt;using namespace std;void PrintListContent(const list&lt;int&gt;&amp; listInput);int main()&#123; list&lt;int&gt; a; list&lt;int&gt; b; b.push_back(100); b.push_back(200); b.push_back(300); b.push_back(400); b.push_back(500); PrintListContent(b); cout &lt;&lt; endl; a.push_front(4); a.push_front(3); a.push_front(2); a.push_front(1); a.push_back(5); //使用链表数据，不能使用下标，只能使用迭代器 list&lt;int&gt;::iterator iter; iter = a.begin(); a.insert(iter, 10);// 在begin前面插入10，第一个参数迭代器，指定插入的位置 a.insert(a.end(),10); PrintListContent(a); //将b插入到a之中 a.insert(a.begin(), b.begin(), b.end()); a.insert(iter,++b.begin(),--b.end()) PrintListContent(a); system("pause"); return 0;&#125;void PrintListContent(const list&lt;int&gt;&amp; listInput)&#123; //会是一个底层 const，即其所指对象可以改变，但不能改变其所指对象的值。 list&lt;int&gt;::const_iterator iter; for (iter = listInput.begin(); iter != listInput.end(); ++iter) &#123; cout &lt;&lt; *iter &lt;&lt; endl; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// listdelet.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include&lt;iostream&gt;#include&lt;list&gt;using namespace std;void PrintListContent(const list&lt;int&gt;&amp; listInput);int main()&#123; list&lt;int&gt; a; a.push_front(4); a.push_front(3); list&lt;int&gt;::iterator iElementValueTwo; iElementValueTwo = a.insert(a.begin(),2); // inset 才返回迭代器迭代器指向这个位置 a.push_front(1); a.push_back(0); cout &lt;&lt; "删除之前" &lt;&lt; endl; PrintListContent(a); // 删除2 cout &lt;&lt; "删除之后" &lt;&lt; endl; a.erase(iElementValueTwo); //a.erase(a.beigin(),iElementValueTwo); 删除从第一个迭代器到第二个迭代器所有的数据 PrintListContent(a); system("pause"); return 0;&#125;void PrintListContent(const list&lt;int&gt;&amp; listInput)&#123; //会是一个底层 const，即其所指对象可以改变，但不能改变其所指对象的值。 cout &lt;&lt; "&#123;"; list&lt;int&gt;::const_iterator iter; for (iter = listInput.begin(); iter != listInput.end(); ++iter) &#123; cout &lt;&lt; *iter &lt;&lt; " "; &#125; cout &lt;&lt; "&#125;" &lt;&lt; endl;&#125;删除之前&#123;1 2 3 4 0 &#125;删除之后&#123;1 3 4 0 &#125;请按任意键继续. . . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// list3.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include&lt;iostream&gt;#include&lt;list&gt;using namespace std;void PrintListContent(const list&lt;int&gt;&amp; listInput);int main()&#123; list&lt;int&gt; a; a.push_front(4); a.push_front(3); a.push_front(2); a.push_front(1); PrintListContent(a); cout &lt;&lt; "反转之后的数据：" &lt;&lt; endl; a.reverse(); PrintListContent(a); list&lt;int&gt; b; b.push_front(4); b.push_front(53); b.push_front(24); b.push_front(132); PrintListContent(b); cout &lt;&lt; "排序之后的数据：" &lt;&lt; endl; b.sort(); PrintListContent(b); system("pause"); return 0;&#125;void PrintListContent(const list&lt;int&gt;&amp; listInput)&#123; //会是一个底层 const，即其所指对象可以改变，但不能改变其所指对象的值。 cout &lt;&lt; "&#123;"; list&lt;int&gt;::const_iterator iter; for (iter = listInput.begin(); iter != listInput.end(); ++iter) &#123; cout &lt;&lt; *iter &lt;&lt; " "; &#125; cout &lt;&lt; "&#125;" &lt;&lt; endl;&#125;&#123;1 2 3 4 &#125;反转之后的数据：&#123;4 3 2 1 &#125;&#123;132 24 53 4 &#125;排序之后的数据：&#123;4 24 53 132 &#125;请按任意键继续. . .]]></content>
      <categories>
        <category>programs</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++中级教程 STL stack]]></title>
    <url>%2F2019%2F07%2F25%2FSTL-stack%2F</url>
    <content type="text"><![CDATA[STL stack (堆) 栈： LIFO 后进先出 自适应容器（容器适配器） 栈适配器 STL stack1234567stack&lt;int, deque&lt;int&gt;&gt; s;stack&lt;int, vector&lt;int&gt;&gt; s;stack&lt;int, list&lt;int&gt;&gt; s;s.empty()s.size()s.pop()s.push(item) 123456789101112131415161718192021222324252627282930313233343536373839404142434445// stack1.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;stack&gt;using namespace std;int main()&#123; stack&lt;int, deque&lt;int&gt;&gt; a; stack&lt;int, vector&lt;int&gt;&gt; b; stack&lt;int, list&lt;int&gt;&gt; c; stack&lt;int&gt; d; //默认用deque //什么是堆栈？ 先进后出，后进先出 d.push(25); d.push(10); d.push(1); d.push(5); int x = 0; cout &lt;&lt; "现在栈里一共有：" &lt;&lt; d.size() &lt;&lt; "个数据。" &lt;&lt; endl; while (d.empty() == false) &#123; x = d.top(); //查看数据并且返回 d.pop();//删除，不返回 cout &lt;&lt; x &lt;&lt; endl; &#125; //x = d.top(); //查看数据并且返回 //d.pop();//删除，不返回 //cout &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; "现在栈里一共有：" &lt;&lt; d.size() &lt;&lt; "个数据。" &lt;&lt; endl; system("pause"); return 0;&#125;现在栈里一共有：4个数据。511025现在栈里一共有：0个数据。请按任意键继续. . .]]></content>
      <categories>
        <category>programs</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
</search>
