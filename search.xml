<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Matplotlib绘制六种可视化图表]]></title>
    <url>%2F2019%2F08%2F24%2Fpythonplot%2F</url>
    <content type="text"><![CDATA[01 折线图1234567891011121314151617import numpy as np import matplotlib.pyplot as pltx = np.linspace(0,2,100)plt.plot(x, x, label='linear')plt.plot(x, x**2, label='quadratic')plt.plot(x, x**3, label='cubic')plt.xlabel('x label')plt.ylabel('y label')plt.title("Simple Plot")plt.legend()plt.show() 02 散点图12345678import numpy as npimport matplotlib.pyplot as pltx = np.arange(0., 5., 0.2)# 红色破折号, 蓝色方块 ，绿色三角块plt.plot(x, x, 'r--', x, x**2, 'bs', x, x**3, 'g^')plt.show() 03 直方图123456789101112131415161718192021222324252627282930import numpy as npimport matplotlib.pyplot as pltnp.random.seed(19680801)mu1, sigma1 = 100, 15mu2, sigma2 = 80, 15x1 = mu1 + sigma1 * np.random.randn(10000)x2 = mu2 + sigma2 * np.random.randn(10000)# the histogram of the data# 50：将数据分成50组# facecolor：颜色；alpha：透明度# density：是密度而不是具体数值n1, bins1, patches1 = plt.hist(x1, 50, density=True, facecolor='g', alpha=1)n2, bins2, patches2 = plt.hist(x2, 50, density=True, facecolor='r', alpha=0.2)# n：概率值；bins：具体数值；patches：直方图对象。plt.xlabel('Smarts')plt.ylabel('Probability')plt.title('Histogram of IQ')plt.text(110, .025, r'$\mu=100,\ \sigma=15$')plt.text(50, .025, r'$\mu=80,\ \sigma=15$')# 设置x，y轴的具体范围plt.axis([40, 160, 0, 0.03])plt.grid(True)plt.show() 04 柱状图4.1 并列柱状图123456789101112131415161718192021import numpy as npimport matplotlib.pyplot as pltsize = 5a = np.random.random(size)b = np.random.random(size)c = np.random.random(size)x = np.arange(size)# 有多少个类型，只需更改n即可total_width, n = 0.8, 3 width = total_width / n# 重新拟定x的坐标x = x - (total_width - width) / 2# 这里使用的是偏移plt.bar(x, a, width=width, label='a')plt.bar(x + width, b, width=width, label='b')plt.bar(x + 2 * width, c, width=width, label='c')plt.legend()plt.show() 4.2 叠加柱状图12345678910111213141516171819import numpy as npimport matplotlib.pyplot as pltsize = 5a = np.random.random(size)b = np.random.random(size)c = np.random.random(size)x = np.arange(size)# 这里使用的是偏移plt.bar(x, a, width=0.5, label='a',fc='r')plt.bar(x, b, bottom=a, width=0.5, label='b', fc='g')plt.bar(x, c, bottom=a+b, width=0.5, label='c', fc='b')plt.ylim(0, 2.5)plt.legend()plt.grid(True)plt.show() 05 饼图5.1 普通饼图123456789101112131415import matplotlib.pyplot as pltlabels = 'Frogs', 'Hogs', 'Dogs', 'Logs'sizes = [15, 30, 45, 10]# 设置分离的距离，0表示不分离explode = (0, 0.1, 0, 0) plt.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%', shadow=True, startangle=90)# Equal aspect ratio 保证画出的图是正圆形plt.axis('equal') plt.show() 5.2 嵌套饼图1234567891011121314151617181920212223242526import numpy as npimport matplotlib.pyplot as plt# 设置每环的宽度size = 0.3vals = np.array([[60., 32.], [37., 40.], [29., 10.]])# 通过get_cmap随机获取颜色cmap = plt.get_cmap("tab20c")outer_colors = cmap(np.arange(3)*4)inner_colors = cmap(np.array([1, 2, 5, 6, 9, 10]))print(vals.sum(axis=1))# [92. 77. 39.]plt.pie(vals.sum(axis=1), radius=1, colors=outer_colors, wedgeprops=dict(width=size, edgecolor='w'))print(vals.flatten())# [60. 32. 37. 40. 29. 10.]plt.pie(vals.flatten(), radius=1-size, colors=inner_colors, wedgeprops=dict(width=size, edgecolor='w'))# equal 使得为正圆plt.axis('equal') plt.show() 5.3 极轴饼图12345678910111213141516171819202122import numpy as npimport matplotlib.pyplot as pltnp.random.seed(19680801)N = 10theta = np.linspace(0.0, 2 * np.pi, N, endpoint=False)radii = 10 * np.random.rand(N)width = np.pi / 4 * np.random.rand(N)ax = plt.subplot(111, projection='polar')bars = ax.bar(theta, radii, width=width, bottom=0.0)# left表示从哪开始，# radii表示从中心点向边缘绘制的长度（半径）# width表示末端的弧长# 自定义颜色和不透明度for r, bar in zip(radii, bars): bar.set_facecolor(plt.cm.viridis(r / 10.)) bar.set_alpha(0.5)plt.show() 06 三维图6.1 绘制三维散点图1234567891011121314151617import numpy as npimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Ddata = np.random.randint(0, 255, size=[40, 40, 40])x, y, z = data[0], data[1], data[2]ax = plt.subplot(111, projection='3d') # 创建一个三维的绘图工程# 将数据点分成三部分画，在颜色上有区分度ax.scatter(x[:10], y[:10], z[:10], c='y') # 绘制数据点ax.scatter(x[10:20], y[10:20], z[10:20], c='r')ax.scatter(x[30:40], y[30:40], z[30:40], c='g')ax.set_zlabel('Z') # 坐标轴ax.set_ylabel('Y')ax.set_xlabel('X')plt.show() 6.2 绘制三维平面图12345678910111213141516from matplotlib import pyplot as pltimport numpy as npfrom mpl_toolkits.mplot3d import Axes3Dfig = plt.figure()ax = Axes3D(fig)X = np.arange(-4, 4, 0.25)Y = np.arange(-4, 4, 0.25)X, Y = np.meshgrid(X, Y)R = np.sqrt(X**2 + Y**2)Z = np.sin(R)# 具体函数方法可用 help(function) 查看，如：help(ax.plot_surface)ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap='rainbow')plt.show() 参考链接： https://mp.weixin.qq.com/s/bMvrle-FRvli0pRNi83waQ]]></content>
      <categories>
        <category>programs</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SqueezeNet]]></title>
    <url>%2F2019%2F08%2F20%2Fsqueezenet%2F</url>
    <content type="text"><![CDATA[论文地址: SqueezeNet: AlexNet-level accuracy with 50x fewer parameters and &lt;0.5MB model size非官方代码: pytorch 介绍这篇文章是DeepScal，加州大学伯克利分校，以及斯坦福大学在ICLR 2017发表的一篇文章。文章的主要目的是为了压缩模型，提高运行速度。这篇文章主要提出了SqueezeNet: 使用少量参数保持精度。 结构设计策略这篇文章的首要目标是在保持准确率 的同时，有几个参数的CNN架构。这篇文章在设计CNN架构的时候采取了三个主要策略。这篇文章的主要模块 是Fire模块。 用1x1的卷积核代替3x3的卷积核，从而减少参数量。1x1 卷积的参数比3x3的卷积核少了 9X. 减少3x3 卷积输入通道的数量。假设有一个卷积层, 它完全由3x3 卷积组成。此层中参数的总数量为：(输入通道数) (过滤器数) (3 * 3)。要在squeeze层中将输入的通道数减少。 在网络中减少下采样(maxpooling)实现, 以便卷积层具有较大的特征图。 Fire ModuleFire Module是将原来一层conv层变成两层：squeeze层+expand层，各自带上Relu激活层。在squeeze层里面全是1x1的卷积kernel，数量记为S11；在expand层里面有1x1和3x3的卷积kernel，expand层之后将1x1和3x3的卷积output feature maps在channel维度cat。 自己手推的一张图，字比较丑，也没时间重现写一下。 fire moudle的pytorch代码很奇怪的是论文中用的是3个1x1，以及expand用的是4个1x1的卷积核和4个 3x3的卷积核，但是pytroch版本的代码并没有体现出来。12345678910111213141516171819202122232425262728293031323334class fire(nn.Module): def __init__(self, inplanes,squeeze_planes, expand_planes): super(fire,self).__init__() self.conv1 = nn.Conv2d(inplanes,squeeze_planes, kernel_size=1, stride=1) self.bn1 = nn.BatchNorm2d(squeeze_planes) self.relu1 = nn.ReLU(inplace=True) self.conv2 = nn.Conv2d(squeeze_planes, expand_planes, kernel_size=1, stride=1) self.bn2 = nn.BatchNorm2d(expand_planes) self.conv3 = nn.Conv2d(squeeze_planes,expand_planes,kernel_size=3, stride=1,padding=1) self.bn3 = nn.BatchNorm2d(expand_planes) self.relu2 = nn.ReLU(inplace=True) # using MSR initialization for m in self.modules(): if isinstance(m,nn.Conv2d): n = m.kernel_size[0]*m.kernel_size[1]*m.in_channels m.weight.data.normal_(0,math.sqrt(2./n)) def forward(self,x): x = self.conv1(x) x = self.bn1(x) x = self.relu1(x) out1 = self.conv2(x) out1 = self.bn2(out1) out2 = self.conv3(x) out2 = self.bn3(out2) out = torch.cat([out1,out2],1) out = self.relu2(out) return out SqueezeNet的具体网络结构 实验结果imagenet数据上比较了alexnet，可以看到准确率差不多的情况下，squeezeNet模型参数数量显著降低了（下表倒数第三行），参数减少50X；如果再加上deep compression技术，压缩比可以达到461X！还是不错的结果。 参考文章：https://blog.csdn.net/xbinworld/article/details/50897870]]></content>
      <categories>
        <category>轻量级网络</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>论文阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治算法]]></title>
    <url>%2F2019%2F08%2F19%2F%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[问题： 给定一组数，要求从中找出第k小的元素。分析：这里通过快速排序算法来解决次问题。记一趟快速排序后，左子集中的元素个数为nleft，则选择问题，可能是一下几种情况之一： nleft等于k-1，则枢纽值即为所求； nleft大于k-1,则继续在左子树中找； nleft小于k-1,则继续在右子集中找C++代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344// t5.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &quot;stdafx.h&quot;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;int quickSelect(int a[], int l, int r, int k)&#123; int p = rand() % (r - l + 1) + l; int pivot = a[p]; &#123;int t = a[p]; a[p] = a[r]; a[r] = t; &#125; int i = l,j = r; while (i &lt; j) &#123; while (i &lt; j&amp;&amp;a[i] &lt; pivot) i++; if (i &lt; j) &#123; a[j] = a[i]; j--; &#125; while (i &lt; j&amp;&amp;a[i] &gt;pivot) j--; if (i &lt; j) &#123; a[i] = a[j]; i++; &#125; &#125; a[i] = pivot; p = i; if (i - l + 1 == k) return a[i]; // j + 1, right, k - (j - left + 1)1) if (i - l + 1 &lt; k) return quickSelect(a, i+1, r, k-i+l-1); else return quickSelect(a, l, i-1, k);&#125;int main()&#123; int a[] = &#123; 1,4,54,8,3,7,45,58,27,8,25,26,21,12 &#125;; printf_s(&quot;%d\n&quot;, quickSelect(a, 0, 14, 6)); system(&quot;pause&quot;); return 0;&#125;]]></content>
      <categories>
        <category>programs</category>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MobileNetsV2]]></title>
    <url>%2F2019%2F08%2F19%2FMobileNetsV2%2F</url>
    <content type="text"><![CDATA[论文地址:MobileNetV2: Inverted Residuals and Linear Bottlenecks 非官方代码:pytorch 介绍这篇文章是谷歌在2019提出来的文章在MobileNets 基础上做的改进。 深度可分离卷积示例 首先在Xception 中被广泛使用 好处： 理论上可以成倍的减少卷积层的时间复杂度和空间复杂度 文章内容与MobileNets 的对比 相同点 都采用 Depth-wise (DW) 卷积搭配 Point-wise (PW) 卷积的方式来提特征 不同点 Linear Bottleneck V2 在 DW 卷积之前新加了一个 PW 卷积。 DW卷积由于本身的计算特性不能改变通道数的能力。若通道数很少的话，DW在提取地低纬特征，效果可能并不会好。 在每个DW之前，增加了PW用于升维，这样DW可以更好的提取特征 V2 去掉了第二个 PW 的激活函数 激活函数在高维空间能够有效的增加非线性，而在低维空间时则会破坏特征 第二个 PW 的主要功能就是降维 与ResNet的对比 相同点 MobileNet V2 借鉴 ResNet，都采用了 1x1-&gt;3x3-&gt;1x1的模式 MobileNet V2 借鉴 ResNet，同样使用 Shortcut 将输出与输入相加 不同点 Inverted Residual Block ResNet 使用 标准卷积 提特征，MobileNet 始终使用 DW卷积 提特征 ResNet 先降维 (0.25倍)、卷积、再升维，而 MobileNet V2 则是 先升维 (6倍)、卷积、再降维。直观的形象上来看，ResNet 的微结构是沙漏形，而 MobileNet V2 则是纺锤形，刚好相反。因此论文作者将 MobileNet V2 的结构称为 Inverted Residual Block。使用DW卷积而作的适配，特征提取能够在高维进行 结论 MobileNets 与MobileNets V2在模型结构上的对比 MobileNetsV2 的卷积层数比V1要多，但是时间复杂度，以及空间复杂度，以及在cpu上的推理时间要远远优于MobileNets 参考文章：https://zhuanlan.zhihu.com/p/33075914]]></content>
      <categories>
        <category>轻量级网络</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>论文阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MobileNets]]></title>
    <url>%2F2019%2F08%2F19%2FMobileNets%2F</url>
    <content type="text"><![CDATA[论文地址:MobileNets: Efficient Convolutional Neural Networks for Mobile Vision Applications 非官方代码:pytorch/models 前言这篇文章是谷歌在2017针对手机等嵌入式设备提出的一种轻量级深层网络，这篇论文主要的贡献点在于提出了一种深度可分离卷积。 主要解决的问题是注重优化延迟，同时也兼顾了模型的大小，不像有些模型虽然参数量比较小，但是速度也是慢的可以。 MobileNets使用了大量的3 × 3的卷积核，极大地减少了计算量（1/8到1/9之间），同时准确率下降的很少，相比其他的方法确有优势。 深度可分离卷积示例 模型结构和训练MobileNets结构建立在上述深度可分解卷积中（只有第一层是标准卷积）。该网络允许我们探索网络拓扑，找到一个适合的良好网络。其具体架构在表1说明。除了最后的全连接层，所有层后面跟了batchnorm和ReLU，最终输入到softmax进行分类。图3对比了标准卷积和分解卷积的结构，二者都附带了BN和ReLU层。按照作者的计算方法，MobileNets总共28层（1 + 2 × 13 + 1 = 28）]]></content>
      <categories>
        <category>轻量级网络</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>论文阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多层感知机的反向传播]]></title>
    <url>%2F2019%2F08%2F19%2FMLP-Back-Propagation%2F</url>
    <content type="text"><![CDATA[全连接神经网络是形式上最简单的神经网络，反向传播算法是一种常用的训练神经网络的算法，理解全连接神经网络中的反向传播算法是理解其他更加复杂网络中反向传播算法的重要基础。 参考链接： https://zhuanlan.zhihu.com/p/61863634]]></content>
      <categories>
        <category>Math</category>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典第四章]]></title>
    <url>%2F2019%2F08%2F18%2Falgorithm4%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157// t4.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;//素数判断方法2#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;#define Max 1000000#define maxn 100int left, chance; //还需要left位置，错chance之后就会输char s[maxn], s2[maxn]; //答案是字符串s, 玩家猜的字母序列是s2int win, lose; // win=1 表示已经赢了; lose=1 表示已经输了long fac(int n) &#123; if (0 == n || 1 == n) &#123; return 1; &#125; else &#123; return fac(n - 1)*n; &#125;&#125;// 非递归的阶乘方法 long fact(int n)&#123; long iRes = 1; for (int i = 1; i &lt;= n; i++) &#123; iRes *= i; &#125; return iRes;&#125;int combination(int m, int n)&#123; long iRes = fac(n) / (fac(m)*fac(n - m)); // long iRes = fact(n) /(fac(m)*fac(n-m)); printf_s(&quot;%ld %.2lf \n&quot;, iRes, (double)clock() / CLOCKS_PER_SEC); return iRes;&#125;// 刽子手游戏---guess函数void guess(char ch)&#123; int bad = 1; for (int i = 0; i &lt; strlen(s); i++) if (s[i] == ch) &#123; left--; s[i] = &apos; &apos;; bad = 0; &#125; if (bad) --chance; if (!chance) lose = 1; if (!left) win = 1;&#125;int main()&#123; /* 关键: 1 用素数筛选法先预处理，默认刚开始全为素数，然后对素数的倍数标记为非素数， for(int j = i*i ; j &lt;= 10000 ; j += i)&#123;iPrimeArr[j] = 1;&#125; 2 通过开根号判断素数时，可以用floor,注意浮点数加上0.5，int iRadical = floor(sqrt(n*1.0) + 0.5); 3 可以用assert()对输入的合法性进行校验，assert(n &gt;= 5 &amp;&amp; n &lt;= 10000);void assert(int exp),如果表达式的值为0则退出。*/ //int sum = 1; //for (int i = 3; i &lt;= Max; i += 2) //&#123; // //因为偶数除了2 都不是质数 // int j; // for (j = 2; j &lt;= (int)sqrt(i); j++)//利用上述结论判断 // if (i%j == 0) break; // if (j &gt; (int)sqrt(i)) // sum++; //&#125; //printf_s(&quot;Time used = %0.2f s\n&quot;, (double)clock() / CLOCKS_PER_SEC); //printf_s(&quot;%d\n&quot;, sum); //int a, b; //scanf_s(&quot;%d %d&quot;, &amp;a, &amp;b); //combination(a, b); //刽子手游戏 /* 游戏规则是这样的：计算机想一个单词让你猜，你每次可以猜一个字母。 如果单词里有那个字母，所有该字母会显示出来；如果没有那个字母，则计算机会在一幅“刽子手”画上填一笔。 这幅画一共需要7笔就能完成，因此你最多只能错6次。 注意，猜一个已经猜过的字母也算错。 在本题中，你的任务是编写一个“裁判”程序，输入单词和玩家的猜测，判断玩家赢了（You win.）、 输了（You lose.）还是放弃了（You chickened out.）。 每组数据包含3行，第1行是游戏编号（-1为输入结束标记），第2行是计算机想的单词，第3行是玩家的猜测。 后两行保证只含小写字母。 */ //char ans[21]; //char gus[28]; //int times, yes; //int chances = 7; //int win = 0; //int lose = 0; //scanf_s(&quot;%d&quot;, &amp;times); //while (times != -1) //&#123; // printf_s(&quot;Round %d\n&quot;, times); // scanf_s(&quot;%s\n %s&quot;, ans, gus); // printf_s(&quot;Round %s &amp;s\n&quot;, ans, gus); // yes = 0; // win = 0, lose = 0, chances = 7; // for (int i = 0; i &lt; strlen(gus); i++) // &#123; // int flag = 0; // for (int j = 0; j &lt; strlen(ans); j++) // &#123; // if (ans[j] == gus[i]) // &#123; // yes++; // flag = 1;//找到之后不退出，因为有一个有相同的字母 // &#125; // if (flag == 0) // &#123; // chances--; // &#125; // if (chances == 0) // &#123; // lose = 1; // printf_s(&quot;You lose.\n&quot;); // &#125; // else if (yes == strlen(ans)) // &#123; // win = 1; // printf_s(&quot;You win.\n&quot;); // break; // &#125; // if (win != 1 &amp;&amp; lose != 1) // &#123; // printf(&quot;You chickened out.\n&quot;); // &#125; // scanf_s(&quot;%d&quot;, &amp;times); // &#125; // &#125; //&#125; int rnd; while (scanf_s(&quot;%d%s%s&quot;, &amp;rnd, &amp;s, &amp;s2) == 3 &amp;&amp; rnd != -1) &#123; printf_s(&quot;%Round %d\n&quot;, rnd); win = lose = 0; left = strlen(s); chance = 7; for (int i = 0; i &lt; strlen(s2); i++) &#123; guess(s2[i]); //猜一个字母 if (win || lose) break; //检查状态 &#125; //根据结果进行输出 if (win) printf_s(&quot;You win.\n&quot;); else if (lose) printf_s(&quot;You lose.\n&quot;); else printf_s(&quot;You chickened out.\n&quot;); &#125; system(&quot;pause&quot;); return 0;&#125;]]></content>
      <categories>
        <category>programs</category>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典第三章]]></title>
    <url>%2F2019%2F08%2F16%2Falgorithm3%2F</url>
    <content type="text"><![CDATA[今天心情不好，所以就敲了这一点代码，希望明天的状态能好一点！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// t3.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &quot;stdio.h&quot;#include &lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;#define maxn 10000000 +10char s[maxn];int main()&#123; //题目1 统计个数 /*int count =0; int temp; while (~scanf_s(&quot;%d&quot;, &amp;temp)) &#123; count++; &#125; printf_s(&quot;%d&quot;, count);*/ //显示不出来 //输入一些数，求最大值、最小值和平均数 //int min, max, n, sum,count = 0; //float avg; //scanf_s(&quot;%d&quot;, &amp;n); //max = n; //min = n; //sum = n; //count++; //while (scanf_s(&quot;%d&quot;, &amp;n)!=EOF) //&#123; // count++; // sum += n; // if (n &gt; max) // max = n; // if (n &lt; min) // min = n; //&#125; //avg = sum*1.0 / count; //printf_s(&quot;%d %d %f\n&quot;, max,min,avg); //5.输入一些数 ，求出他们的方差 /*double ave, sum = 0, varance, psum = 0; int n.a[110], count = 0; while (scanf_s(&quot;%d&quot;, &amp;n) != EOF) &#123; a[count++] = n; sum += n; &#125; avg = sum*1.0 / count; for (int i = 0; i &lt; count; i++) psum += (a[i] - ave)*(a[i] - ave); variance = psum / count; print(&quot;%lf&quot;, variance);*/ scanf_s(&quot;%s&quot;, s); int tot = 0; for (int i = 0;s[i]; i++) &#123; if (s[i] == &apos;1&apos;) tot++; &#125; printf_s(&quot;%d\n&quot;, tot); system(&quot;pause&quot;); return 0;&#125;]]></content>
      <categories>
        <category>programs</category>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LNMS]]></title>
    <url>%2F2019%2F08%2F16%2FLNMS%2F</url>
    <content type="text"><![CDATA[locality NMSLNMS是在EAST文本检测中提出的．主要原因：文本检测面临的是成千上万个几何体，如果用普通的NMS，其计算复杂度，n是几何体的个数，这是不可接受的．对上述时间复杂度问题，EAST提出了基于行合并几何体的方法，当然这是基于邻近几个几何体是高度相关的假设．注意：这里合并的四边形坐标是通过两个给定四边形的得分进行加权平均的，也就是说这里是“平均”而不是”选择”几何体*,目的是减少计算量．基本步骤1.先对所有的output box集合结合相应的阈值（大于阈值则进行合并，小于阈值则不和并），依次遍历进行加权合并，得到合并后的bbox集合；2.对合并后的bbox集合进行标准的NMS操作1234567891011121314151617181920212223242526272829303132333435363738394041424344def detect(score_map, geo_map, timer, score_map_thresh=1e-5, box_thresh=1e-8, nms_thres=0.1): &apos;&apos;&apos; restore text boxes from score map and geo map :param score_map: bs* 128 * 128 * 1 :param geo_map: ## geo_map = bs * 128 * 128 * 5 :param timer: :param score_map_thresh: threshhold for score map :param box_thresh: threshhold for boxes :param nms_thres: threshold for nms :return: &apos;&apos;&apos; if len(score_map.shape) == 4: score_map = score_map[0, :, :, 0] geo_map = geo_map[0, :, :, ] # filter the score map xy_text = np.argwhere(score_map &gt; score_map_thresh) # sort the text boxes via the y axis xy_text = xy_text[np.argsort(xy_text[:, 0])] # restore start = time.time() text_box_restored = restore_rectangle(xy_text[:, ::-1]*4, geo_map[xy_text[:, 0], xy_text[:, 1], :]) # N*4*2 #print(&apos;&#123;&#125; text boxes before nms&apos;.format(text_box_restored.shape[0])) boxes = np.zeros((text_box_restored.shape[0], 9), dtype=np.float32) boxes[:, :8] = text_box_restored.reshape((-1, 8)) boxes[:, 8] = score_map[xy_text[:, 0], xy_text[:, 1]] timer[&apos;restore&apos;] = time.time() - start # 得到box 的坐标以及分数 # nms part start = time.time() # boxes = nms_locality.nms_locality(boxes.astype(np.float64), nms_thres) boxes = lanms.merge_quadrangle_n9(boxes.astype(&apos;float32&apos;), nms_thres) timer[&apos;nms&apos;] = time.time() - start if boxes.shape[0] == 0: return None, timer # here we filter some low score boxes by the average score map, this is different from the orginal paper for i, box in enumerate(boxes): mask = np.zeros_like(score_map, dtype=np.uint8) cv2.fillPoly(mask, box[:8].reshape((-1, 4, 2)).astype(np.int32) // 4, 1) boxes[i, 8] = cv2.mean(score_map, mask)[0] boxes = boxes[boxes[:, 8] &gt; box_thresh] return boxes, timer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import numpy as npfrom shapely.geometry import Polygondef intersection(g, p): #取g,p中的几何体信息组成多边形 g = Polygon(g[:8].reshape((4, 2))) p = Polygon(p[:8].reshape((4, 2))) # 判断g,p是否为有效的多边形几何体 if not g.is_valid or not p.is_valid: return 0 # 取两个几何体的交集和并集 inter = Polygon(g).intersection(Polygon(p)).area union = g.area + p.area - inter if union == 0: return 0 else: return inter/uniondef weighted_merge(g, p): # 取g,p两个几何体的加权（权重根据对应的检测得分计算得到） g[:8] = (g[8] * g[:8] + p[8] * p[:8])/(g[8] + p[8]) #合并后的几何体的得分为两个几何体得分的总和 g[8] = (g[8] + p[8]) return gdef standard_nms(S, thres): #标准NMS order = np.argsort(S[:, 8])[::-1] keep = [] while order.size &gt; 0: i = order[0] keep.append(i) ovr = np.array([intersection(S[i], S[t]) for t in order[1:]]) inds = np.where(ovr &lt;= thres)[0] order = order[inds+1] return S[keep]def nms_locality(polys, thres=0.3): &apos;&apos;&apos; locality aware nms of EAST :param polys: a N*9 numpy array. first 8 coordinates, then prob :return: boxes after nms &apos;&apos;&apos; S = [] #合并后的几何体集合 p = None #合并后的几何体 for g in polys: if p is not None and intersection(g, p) &gt; thres: #若两个几何体的相交面积大于指定的阈值，则进行合并 p = weighted_merge(g, p) else: #反之，则保留当前的几何体 if p is not None: S.append(p) p = g if p is not None: S.append(p) if len(S) == 0: return np.array([]) return standard_nms(np.array(S), thres)if __name__ == &apos;__main__&apos;: # 343,350,448,135,474,143,369,359 print(Polygon(np.array([[343, 350], [448, 135], [474, 143], [369, 359]])).area) 参考博客： https://www.jianshu.com/p/4934875f7eb6]]></content>
      <categories>
        <category>programs</category>
        <category>algorithm</category>
        <category>cv</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>nms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典第二章]]></title>
    <url>%2F2019%2F08%2F15%2Falgorithm2%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187// t2.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &quot;stdio.h&quot;#include &lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;int main()&#123; ////3n+1问题、 //int n, count = 0; //当n过大的时候 2*n溢出 // //scanf_s(&quot;%d&quot;, &amp;n); //long long n2 = n; //while (n2 &gt; 1) //&#123; // if (n2 % 2 == 1) n2 = n2 * 3 + 1; // else n2 /= 2; // count++; //&#125; //printf_s(&quot;%d\n&quot;, count); //近似计算 /*double sum = 0; for (int i = 0;; i++) &#123; double term = 1.0 / (i * 2 + 1); if (i % 2 == 0) sum += term; else sum -= term; if (term &lt; 1e-6) break; &#125; printf_s(&quot;%.6f\n&quot;, sum);*/ // 阶乘之和 只保存后六位 //int n, S = 0; //scanf_s(&quot;%d&quot;, &amp;n); //for (int i = 1; i &lt;= n; i++) //&#123; // int factorial = 1; // for (int j = 1; j &lt;= i; j++) // factorial *= j; // S += factorial; //&#125; //printf_s(&quot;%d\n&quot;, S % 1000000); // 阶乘之和2, 优化版本 //int n, S = 0; //const int MOD = 1000000; //scanf_s(&quot;%d&quot;, &amp;n); //for (int i = 1; i &lt;= n; i++) //&#123; // int factorial = 1; // for (int j = 1; j &lt;= i; j++) // factorial = (factorial *j)%MOD; // S += factorial; //&#125; //printf_s(&quot;%d\n&quot;, S %MOD); //printf_s(&quot;Time used = %.2f\n&quot;, (double)clock() / CLOCKS_PER_SEC); // 得到程序运行的时间 单位：秒 // 数据统计 //习题2.1 水仙花数目 /*int sum; for (int i = 1; i &lt; 10; i++) for (int k = 0; k &lt; 10; k++) for (int j = 0; j &lt; 10; j++) &#123; sum = i * 100 + 10 * k + j; if(sum == i*i*i+j*j*j + k*k*k) printf_s(&quot;%d &quot;, sum); &#125;*/ //习题2.2 韩信点兵 相传韩信才智过人，从不直接清点自己军队的人数，只要让士兵先后以三人一排、五人一排、七人一排地变换队形， //而他每次只掠一眼队伍的排尾就知道总人数了。输入包含多组数据，每组数据包含3个非负整数a，b，c，表示每种队形排尾的人数（a＜3，b＜5，c＜7）， //输出总人数的最小值（或报告无解）。已知总人数不小于10，不超过100。输入到文件结束为止。 //int i, a, b, c; //scanf_s(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); //for (i = 0; i &lt;= 100; i++) &#123; // if (i % 3 == a &amp;&amp; i % 5 == b &amp;&amp; i % 7 == c) // printf_s(&quot;%d\n&quot;, i); // //&#125; //if (i % 3 != a &amp;&amp; i % 5 != b &amp;&amp; i % 7 != c &amp;&amp; i&gt;100) // printf_s(&quot;No answer\n&quot;); //习题2.3 倒三角形 //int n, /* 输出n行; n&lt;=20 */ // i, /* 打印第i行 */ // j; //scanf_s(&quot;%d&quot;, &amp;n); //for (i = 1; i &lt;= n; i = i + 1) &#123; // /* 在第i行，打印(i-1)个空格 */ // for (j = 1; j &lt;= i - 1; j = j + 1) printf_s(&quot; &quot;); // /* 在第i行，打印(2*n-2*i+1)个# */ // for (j = 1; j &lt;= (2 * n - 2 * i + 1); j = j + 1) printf_s(&quot;#&quot;); // printf_s(&quot;\n&quot;); /* 输出结束后换行，否则所有的#号在同一行输出 */ //&#125; //习题2.4 子序列的和 输入两个正整数n＜m＜10 6 ，输出 ，保留5位小数。输入包含多组数据， 注：陷阱就是在n特别大时如果直接n*n就会溢出，所以只能连除两次 //int count = 0; //while (1) &#123; // int n = 0; // int m = 0; // scanf_s(&quot;%d&quot;, &amp;n); // scanf_s(&quot;%d&quot;, &amp;m); // if (n == m&amp;&amp;n == 0) &#123; // break; // &#125; // count++; // double sum = 0; // for (int i = n; i &lt;= m; i++) &#123; // sum += 1.0 / i / i; // &#125; // printf_s(&quot;Case %d:%.5f\n&quot;, count, sum); //&#125; //习题2.5 分数化小数（decimal） //输入正整数a，b，c，输出a / b的小数形式，精确到小数点后c位。a，b≤10 ^ 6，c≤100。输入包含多组数据，结束标记为a＝b＝c＝0。 // int count = 0; //while (1) &#123; // int a, b, c; // int k, d, i; // scanf_s(&quot;%d&quot;, &amp;a); // scanf_s(&quot;%d&quot;, &amp;b); // scanf_s(&quot;%d&quot;, &amp;c); // if (a == 0&amp;&amp;b == 0 &amp;&amp;c==0 ) &#123; // break; // &#125; // count++; // for (i = 0; i&lt;c - 1; i++) // &#123; // /*机智地把余数放大十倍，使之除以b并取模*/ // k = (k%b) * 10; // printf_s(&quot;Case %d:%.5f\n&quot;, count, k / b); // &#125; // k = (k%b) * 10; // d = (k%b) * 10 / b; // if (d &gt;= 5)//判断第c+1位小数是否大于等于5，if yes,第c位小数要进1 // &#123; // printf_s(&quot;Case %d:%.5f\n&quot;, count, k / b + 1); // &#125; // else // &#123; // printf_s(&quot;Case %d:%.5f\n&quot;, count, k / b); // &#125; // //&#125; int abc,def,ghi; int a[10],count=0; memset(a,0,sizeof(a)); // 将a数组中的值全部设置为0 for (abc = 123;abc &lt; 333;abc ++) &#123; // 基本可以确定abc的最小值和最大值 def = 2 * abc; ghi = 3 * abc; // 设置数组中所有对应的9位数字位置的值1 a[abc/100] = 1; // a a[abc/10%10] = 1; // b a[abc%10] = 1; // c a[def/100] = 1; // d a[def/10%10] = 1; // e a[def%10] = 1; // f a[ghi/100] = 1; // g a[ghi/10%10] = 1; // h a[ghi%10] = 1; // i int i; for (i=1;i&lt;=9;i++) &#123; count += a[i]; &#125; if (count == 9) &#123; printf_s(&quot;%d %d %d\n&quot;,abc,def,ghi); &#125; // 重置count 和a数组 count = 0; memset(a,0,sizeof(a)); &#125; system(&quot;pause&quot;); return 0; &#125;]]></content>
      <categories>
        <category>programs</category>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典第一章]]></title>
    <url>%2F2019%2F08%2F14%2Falgorithm1%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// t1.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &quot;stdio.h&quot;#include &lt;stdlib.h&gt;#include&lt;math.h&gt; int main()&#123; //printf(&quot;%.1f\n&quot;, 8.0 / 5.0); // %点后面是保留几位浮点小数1.6 //printf(&quot;%.1f\n&quot;, 8 / 5); // %点后面是保留几位浮点小数 结果为0 //printf(&quot;%d\n&quot;, 8.0 / 5.0); // 整数值用%d输出，实数用%f输出 # int 是2字节 ，float是4字节 溢出 // //整数/整数等与整数，浮点数除以浮点数等于浮点数 //printf(&quot;%.8f\n&quot;, 1 + 2 * sqrt(3) / (5 - 0.1)); //int a, b; //scanf_s(&quot;%d%d&quot;, &amp;a, &amp;b); //scanf_s 中的占位符要和变量的数据类型一一对应，要在变量前面加上“&amp;”符号 //printf(&quot;%d\n&quot;, a+b); //const double pi = acos(-1.0); //double r, h, s1, s2, s; //scanf_s(&quot;%1f%1f&quot;, &amp;r, &amp;h); //s1 = pi*r*r; //s2 = 2 * pi*r*h; //s = s1*2.0 + s2; //printf_s(&quot;Area = %.3f\n&quot;, s); //交换变量 //int a, b, m, n; //scanf_s(&quot;%d%d&quot;, &amp;a, &amp;b); ///*a = a + b; //b = a - b; //a = a - b;*/ //printf_s(&quot;%d %d\n&quot;, b, a); //int a, b, m, n; //scanf_s(&quot;%d%d&quot;, &amp;n, &amp;m); ///*a = a + b; //b = a - b; //a = a - b;*/ //a = (4*n-m) / 2; //b = n - a; //if (m % 2 == 1 || a &lt; 0 || b &lt; 0) // printf_s(&quot;No answer!\n&quot;); //else // printf_s(&quot;Answer is chicken %d rabbit %d\n&quot;, a, b); //exp1 输入三个整数，求出他们的平均数，保留三位小数 //int a, b, c; //scanf_s(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); //printf_s(&quot;%.3f&quot;, (a + b + c) / 3.0); //exp2 输入华氏温度f,输出对应的摄氏温度c,保留3位小数.提示 : c = 5(f-32)/9. //float f, c; //scanf_s(&quot;%f&quot;, &amp;f); //c = 5*(f - 32) / 9.0; //printf_s(&quot;摄制温度为： %.3f&quot;, c); //exp3 //int n; //scanf_s(&quot;%d&quot;, &amp;n); //printf_s(&quot;%d&quot;, n*(n + 1) / 2); //exp4 输入正整数《360 ，输出正弦余弦函数值。提示：使用数学函数 //int n; // #define PI 3.1415926 //scanf_s(&quot;%d&quot;, &amp;n); //if (n &lt; 0 || n&gt;360) // printf_s(&quot;error&quot;); //else //&#123; // printf_s(&quot;%.2f\n&quot;, cos(n*PI/180)); // printf_s(&quot;%.2f&quot;, sin(n*PI / 180)); //&#125; // // exp5 一件衣服95元，若消费满300元可以打85折，输入购买衣服的简书，输出需要支付的金额。保留两位小数 //int n,money; //scanf_s(&quot;%d&quot;, &amp;n); //money = n * 95; //if (money &gt; 300) // printf_s(&quot;%.2f&quot;, money* 0.85); //else // printf_s(&quot;%.2f&quot;, money); // //exp6 判断三个边是否能构成直角三角形 边长均为正整数 //int a, b, c; //scanf_s(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); //if (((a*a + b*b)== c*c) || ((a*a + c*c) == b*b) || ((c*c + b*b) == a*a)) // printf_s(&quot;yes\n&quot;); //else // printf_s(&quot;not a triangle\n&quot;); //exp7 判断一个年是不是闰年 能被4整除但是不能被100整除的年份 //int n; //scanf_s(&quot;%d&quot;, &amp;n); //if (n % 4 == 0 &amp;&amp; n % 100 != 0) // printf_s(&quot;yes\n&quot;); //else // printf_s(&quot;no\n&quot;); // //q1: int类型的最大值和最小值是多少 2^(n - 1) - 1 -2^(n - 1) //q2; double浮点数能精确到多少位小数？ 遵循IEEE标准的8字节（64位）的double能表示的有效数字的位数是：15 ~ 16 //q3: double类型的最大正数值和最小正数值 //q4: 逻辑运算符号的优先级 system(&quot;pause&quot;); return 0;&#125; 思考题解析： https://blog.csdn.net/panderang/article/details/54096426]]></content>
      <categories>
        <category>programs</category>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F07%2F29%2F%E6%96%87%E6%9C%AC%E6%A3%80%E6%B5%8B%E8%B0%83%E7%A0%94%2F</url>
    <content type="text"><![CDATA[文本检测问题，广义上来说可以看做是一个目标检测的问题，但是相当于目标检测要简单的多。因为目标检测往往除了背景还有其他的类，而文本检测，只需要检测背景和文本类两个问题。因此可以采用目标检测或者分割的方法来进行文本检测。而视频中的文本检测，也可以看做是视频中的目标检测中的一种，感觉应该也可以用视频中的目标检测+跟踪来做。 通常目标跟踪面临的极大难点：物体变形、亮度变化、快速移动、背景干扰覆盖。其中最主要的三个难题分别是目标背景的变化，物体本身的变化，光照强度的变化。 光流法帧间差分法背景差分法]]></content>
  </entry>
  <entry>
    <title><![CDATA[c++中级教程 顺序容器的定义]]></title>
    <url>%2F2019%2F07%2F26%2F%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[顺序容器的定义 顺序容器 vector list deque 顺序容器适配器 stack queue priority_queue]]></content>
      <categories>
        <category>programs</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++中级教程 STL queue]]></title>
    <url>%2F2019%2F07%2F26%2FSTLqueue%2F</url>
    <content type="text"><![CDATA[STL queue 队列： FIFO 先进先出 自适应容器（容器适配器） 栈适配器 STL queue12345678queue&lt;int, deque&lt;int&gt;&gt; q;queue&lt;int, list&lt;int&gt;&gt; q;q.empty()q.size()q.front()q.back()q.pop()q.push(item) 可以用list和deque做queue先进先出，后进后出12345678910111213141516171819202122232425262728293031323334353637383940// queue.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;list&gt;#include&lt;deque&gt;using namespace std;int main()&#123; queue&lt;int, deque&lt;int&gt;&gt; a; queue&lt;int, list&lt;int&gt;&gt; b; //queue&lt;int, vector&lt;int&gt;&gt; c; 不可以，因为vector不能进行两端操作 //队列有什么用途？？？ queue&lt;int&gt; q; q.push(10); q.push(5); q.push(-1); q.push(20); cout &lt;&lt; "现在队列里有" &lt;&lt; q.size() &lt;&lt; "个数据 " &lt;&lt; endl; cout &lt;&lt; "队首的数据：" &lt;&lt; q.front() &lt;&lt; endl; cout &lt;&lt; "队尾的数据：" &lt;&lt; q.back() &lt;&lt; endl; q.pop(); cout &lt;&lt; "新的队首的数据：" &lt;&lt; q.front() &lt;&lt; endl; while (q.size() != 0) &#123; cout &lt;&lt; " 删除" &lt;&lt; a.front() &lt;&lt; endl; q.pop(); &#125; if (q.empty()) &#123; cout &lt;&lt; "队列为空！"&lt;&lt;endl; &#125; system("pause"); return 0;&#125; 优先级队列 priority_queue 自适应容器（容器适配器）：不能使用list 最大值优先级队列、最小值优先级队列(值越大，优先级越高，值越小优先级越高) 优先级队列适配器 STL priority_queue 1234567891011priority_queue&lt;int, deque&lt;int&gt;&gt; pg1;//对队列里的数据进行随机操作，所以不能使用listpriority_queue&lt;int, vector&lt;int&gt;&gt; pg2; //vector是默认的 //谓词priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; pg2; //vector是默认的，最小优先队列pg.empty()pg.size()pg.top()pg.pop()pg.push(item)~~~~~~~~~~ 1234567891011121314151617181920212223242526272829303132333435363738394041// priority_queue.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include&lt;iostream&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;int main()&#123; priority_queue&lt;int, deque&lt;int&gt;&gt; pg1; //对队列里的数据进行随机操作，所以不能使用list priority_queue&lt;int, vector&lt;int&gt;&gt; pg2; //vector是默认的 //谓词 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; pg2; //vector是默认的，最小优先队列 pg2.push(10); pg2.push(5); pg2.push(-1); pg2.push(20); cout &lt;&lt; &quot;优先级队列一共有： &quot; &lt;&lt; pg2.size() &lt;&lt; &quot;个数据&quot; &lt;&lt; endl; cout &lt;&lt; pg2.top() &lt;&lt; endl; while (!pg2.empty()) &#123; cout &lt;&lt; &quot;从优先级队列里删除： &quot; &lt;&lt; pg2.top() &lt;&lt; endl; pg2.pop(); &#125; system(&quot;pause&quot;); return 0;&#125;优先级队列一共有： 4个数据20从优先级队列里删除： 20从优先级队列里删除： 10从优先级队列里删除： 5从优先级队列里删除： -1请按任意键继续. . .~~]]></content>
      <categories>
        <category>programs</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++中级教程(一)]]></title>
    <url>%2F2019%2F07%2F25%2F%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8-STL-deque-%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[顺序容器 STL deque 类 deque是一个动态数组 deque与vector 非常类似 deque可以在数组开头和末尾插入和删除数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// demo3.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include &lt;iostream&gt;#include &lt;deque&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; deque&lt;int&gt; a; a.push_back(3); a.push_back(4); a.push_back(5); a.push_back(6); //vector只能push_back a.push_front(2); a.push_front(1); a.push_front(9); a.push_front(8); for (size_t nCount = 0; nCount &lt; a.size(); ++nCount) &#123; cout &lt;&lt;"a["&lt;&lt;nCount&lt;&lt;"]" &lt;&lt; "= " &lt;&lt; a[nCount] &lt;&lt; endl; &#125; cout &lt;&lt; endl&lt;&lt;endl; a.pop_front();// 前面删除 a.pop_back();// 后面删除 cout &lt;&lt; "删除之后：" &lt;&lt; endl; /*for (size_t nCount = 0; nCount &lt; a.size(); ++nCount) &#123; cout &lt;&lt; "a[" &lt;&lt; nCount &lt;&lt; "]" &lt;&lt; a[nCount] &lt;&lt; endl; &#125;*/ deque&lt;int&gt;::iterator iElementLocater; //这边使用了迭代器 distence 可以计算当前 for (iElementLocater = a.begin(); iElementLocater != a.end(); ++iElementLocater) &#123; size_t nOffset = distance(a.begin(), iElementLocater);//distence 可以计算当前下标与begin开始的，距离正好是下标 cout &lt;&lt; "a[" &lt;&lt; nOffset &lt;&lt; "]" &lt;&lt; "= "&lt;&lt;*iElementLocater &lt;&lt; endl; &#125; system("pause"); return 0;&#125;a[0]= 8a[1]= 9a[2]= 1a[3]= 2a[4]= 3a[5]= 4a[6]= 5a[7]= 6删除之后：a[0]= 9a[1]= 1a[2]= 2a[3]= 3a[4]= 4a[5]= 5请按任意键继续. . . 順序容器 STL list 類 实例化std::list对象 在list开头插入元素 在list末尾插入元素 在list中间插入元素 删除list中的元素 对list中的元素进行反转和排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// list.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include&lt;iostream&gt;#include&lt;list&gt;using namespace std;void PrintListContent(const list&lt;int&gt;&amp; listInput);int main()&#123; list&lt;int&gt; a; list&lt;int&gt; b; b.push_back(100); b.push_back(200); b.push_back(300); b.push_back(400); b.push_back(500); PrintListContent(b); cout &lt;&lt; endl; a.push_front(4); a.push_front(3); a.push_front(2); a.push_front(1); a.push_back(5); //使用链表数据，不能使用下标，只能使用迭代器 list&lt;int&gt;::iterator iter; iter = a.begin(); a.insert(iter, 10);// 在begin前面插入10，第一个参数迭代器，指定插入的位置 a.insert(a.end(),10); PrintListContent(a); //将b插入到a之中 a.insert(a.begin(), b.begin(), b.end()); a.insert(iter,++b.begin(),--b.end()) PrintListContent(a); system("pause"); return 0;&#125;void PrintListContent(const list&lt;int&gt;&amp; listInput)&#123; //会是一个底层 const，即其所指对象可以改变，但不能改变其所指对象的值。 list&lt;int&gt;::const_iterator iter; for (iter = listInput.begin(); iter != listInput.end(); ++iter) &#123; cout &lt;&lt; *iter &lt;&lt; endl; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// listdelet.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include&lt;iostream&gt;#include&lt;list&gt;using namespace std;void PrintListContent(const list&lt;int&gt;&amp; listInput);int main()&#123; list&lt;int&gt; a; a.push_front(4); a.push_front(3); list&lt;int&gt;::iterator iElementValueTwo; iElementValueTwo = a.insert(a.begin(),2); // inset 才返回迭代器迭代器指向这个位置 a.push_front(1); a.push_back(0); cout &lt;&lt; "删除之前" &lt;&lt; endl; PrintListContent(a); // 删除2 cout &lt;&lt; "删除之后" &lt;&lt; endl; a.erase(iElementValueTwo); //a.erase(a.beigin(),iElementValueTwo); 删除从第一个迭代器到第二个迭代器所有的数据 PrintListContent(a); system("pause"); return 0;&#125;void PrintListContent(const list&lt;int&gt;&amp; listInput)&#123; //会是一个底层 const，即其所指对象可以改变，但不能改变其所指对象的值。 cout &lt;&lt; "&#123;"; list&lt;int&gt;::const_iterator iter; for (iter = listInput.begin(); iter != listInput.end(); ++iter) &#123; cout &lt;&lt; *iter &lt;&lt; " "; &#125; cout &lt;&lt; "&#125;" &lt;&lt; endl;&#125;删除之前&#123;1 2 3 4 0 &#125;删除之后&#123;1 3 4 0 &#125;请按任意键继续. . . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// list3.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include&lt;iostream&gt;#include&lt;list&gt;using namespace std;void PrintListContent(const list&lt;int&gt;&amp; listInput);int main()&#123; list&lt;int&gt; a; a.push_front(4); a.push_front(3); a.push_front(2); a.push_front(1); PrintListContent(a); cout &lt;&lt; "反转之后的数据：" &lt;&lt; endl; a.reverse(); PrintListContent(a); list&lt;int&gt; b; b.push_front(4); b.push_front(53); b.push_front(24); b.push_front(132); PrintListContent(b); cout &lt;&lt; "排序之后的数据：" &lt;&lt; endl; b.sort(); PrintListContent(b); system("pause"); return 0;&#125;void PrintListContent(const list&lt;int&gt;&amp; listInput)&#123; //会是一个底层 const，即其所指对象可以改变，但不能改变其所指对象的值。 cout &lt;&lt; "&#123;"; list&lt;int&gt;::const_iterator iter; for (iter = listInput.begin(); iter != listInput.end(); ++iter) &#123; cout &lt;&lt; *iter &lt;&lt; " "; &#125; cout &lt;&lt; "&#125;" &lt;&lt; endl;&#125;&#123;1 2 3 4 &#125;反转之后的数据：&#123;4 3 2 1 &#125;&#123;132 24 53 4 &#125;排序之后的数据：&#123;4 24 53 132 &#125;请按任意键继续. . .]]></content>
      <categories>
        <category>programs</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[firstblog]]></title>
    <url>%2F2019%2F07%2F25%2Ffirstblog%2F</url>
    <content type="text"><![CDATA[以上是摘要 Hello World]]></content>
      <categories>
        <category>dailylife</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++中级教程 STL stack]]></title>
    <url>%2F2019%2F07%2F25%2FSTL-stack%2F</url>
    <content type="text"><![CDATA[STL stack (堆) 栈： LIFO 后进先出 自适应容器（容器适配器） 栈适配器 STL stack1234567stack&lt;int, deque&lt;int&gt;&gt; s;stack&lt;int, vector&lt;int&gt;&gt; s;stack&lt;int, list&lt;int&gt;&gt; s;s.empty()s.size()s.pop()s.push(item) 123456789101112131415161718192021222324252627282930313233343536373839404142434445// stack1.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;stack&gt;using namespace std;int main()&#123; stack&lt;int, deque&lt;int&gt;&gt; a; stack&lt;int, vector&lt;int&gt;&gt; b; stack&lt;int, list&lt;int&gt;&gt; c; stack&lt;int&gt; d; //默认用deque //什么是堆栈？ 先进后出，后进先出 d.push(25); d.push(10); d.push(1); d.push(5); int x = 0; cout &lt;&lt; "现在栈里一共有：" &lt;&lt; d.size() &lt;&lt; "个数据。" &lt;&lt; endl; while (d.empty() == false) &#123; x = d.top(); //查看数据并且返回 d.pop();//删除，不返回 cout &lt;&lt; x &lt;&lt; endl; &#125; //x = d.top(); //查看数据并且返回 //d.pop();//删除，不返回 //cout &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; "现在栈里一共有：" &lt;&lt; d.size() &lt;&lt; "个数据。" &lt;&lt; endl; system("pause"); return 0;&#125;现在栈里一共有：4个数据。511025现在栈里一共有：0个数据。请按任意键继续. . .]]></content>
      <categories>
        <category>programs</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
</search>
