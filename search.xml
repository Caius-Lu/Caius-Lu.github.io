<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法竞赛入门经典第一章]]></title>
    <url>%2F2019%2F08%2F14%2Falgorithm1%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// t1.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &quot;stdio.h&quot;#include &lt;stdlib.h&gt;#include&lt;math.h&gt; int main()&#123; //printf(&quot;%.1f\n&quot;, 8.0 / 5.0); // %点后面是保留几位浮点小数1.6 //printf(&quot;%.1f\n&quot;, 8 / 5); // %点后面是保留几位浮点小数 结果为0 //printf(&quot;%d\n&quot;, 8.0 / 5.0); // 整数值用%d输出，实数用%f输出 # int 是2字节 ，float是4字节 溢出 // //整数/整数等与整数，浮点数除以浮点数等于浮点数 //printf(&quot;%.8f\n&quot;, 1 + 2 * sqrt(3) / (5 - 0.1)); //int a, b; //scanf_s(&quot;%d%d&quot;, &amp;a, &amp;b); //scanf_s 中的占位符要和变量的数据类型一一对应，要在变量前面加上“&amp;”符号 //printf(&quot;%d\n&quot;, a+b); //const double pi = acos(-1.0); //double r, h, s1, s2, s; //scanf_s(&quot;%1f%1f&quot;, &amp;r, &amp;h); //s1 = pi*r*r; //s2 = 2 * pi*r*h; //s = s1*2.0 + s2; //printf_s(&quot;Area = %.3f\n&quot;, s); //交换变量 //int a, b, m, n; //scanf_s(&quot;%d%d&quot;, &amp;a, &amp;b); ///*a = a + b; //b = a - b; //a = a - b;*/ //printf_s(&quot;%d %d\n&quot;, b, a); //int a, b, m, n; //scanf_s(&quot;%d%d&quot;, &amp;n, &amp;m); ///*a = a + b; //b = a - b; //a = a - b;*/ //a = (4*n-m) / 2; //b = n - a; //if (m % 2 == 1 || a &lt; 0 || b &lt; 0) // printf_s(&quot;No answer!\n&quot;); //else // printf_s(&quot;Answer is chicken %d rabbit %d\n&quot;, a, b); //exp1 输入三个整数，求出他们的平均数，保留三位小数 //int a, b, c; //scanf_s(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); //printf_s(&quot;%.3f&quot;, (a + b + c) / 3.0); //exp2 输入华氏温度f,输出对应的摄氏温度c,保留3位小数.提示 : c = 5(f-32)/9. //float f, c; //scanf_s(&quot;%f&quot;, &amp;f); //c = 5*(f - 32) / 9.0; //printf_s(&quot;摄制温度为： %.3f&quot;, c); //exp3 //int n; //scanf_s(&quot;%d&quot;, &amp;n); //printf_s(&quot;%d&quot;, n*(n + 1) / 2); //exp4 输入正整数《360 ，输出正弦余弦函数值。提示：使用数学函数 //int n; // #define PI 3.1415926 //scanf_s(&quot;%d&quot;, &amp;n); //if (n &lt; 0 || n&gt;360) // printf_s(&quot;error&quot;); //else //&#123; // printf_s(&quot;%.2f\n&quot;, cos(n*PI/180)); // printf_s(&quot;%.2f&quot;, sin(n*PI / 180)); //&#125; // // exp5 一件衣服95元，若消费满300元可以打85折，输入购买衣服的简书，输出需要支付的金额。保留两位小数 //int n,money; //scanf_s(&quot;%d&quot;, &amp;n); //money = n * 95; //if (money &gt; 300) // printf_s(&quot;%.2f&quot;, money* 0.85); //else // printf_s(&quot;%.2f&quot;, money); // //exp6 判断三个边是否能构成直角三角形 边长均为正整数 //int a, b, c; //scanf_s(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); //if (((a*a + b*b)== c*c) || ((a*a + c*c) == b*b) || ((c*c + b*b) == a*a)) // printf_s(&quot;yes\n&quot;); //else // printf_s(&quot;not a triangle\n&quot;); //exp7 判断一个年是不是闰年 能被4整除但是不能被100整除的年份 //int n; //scanf_s(&quot;%d&quot;, &amp;n); //if (n % 4 == 0 &amp;&amp; n % 100 != 0) // printf_s(&quot;yes\n&quot;); //else // printf_s(&quot;no\n&quot;); // //q1: int类型的最大值和最小值是多少 2^(n - 1) - 1 -2^(n - 1) //q2; double浮点数能精确到多少位小数？ 遵循IEEE标准的8字节（64位）的double能表示的有效数字的位数是：15 ~ 16 //q3: double类型的最大正数值和最小正数值 //q4: 逻辑运算符号的优先级 system(&quot;pause&quot;); return 0;&#125; 思考题解析： https://blog.csdn.net/panderang/article/details/54096426]]></content>
      <categories>
        <category>programs</category>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F07%2F29%2F%E6%96%87%E6%9C%AC%E6%A3%80%E6%B5%8B%E8%B0%83%E7%A0%94%2F</url>
    <content type="text"><![CDATA[文本检测问题，广义上来说可以看做是一个目标检测的问题，但是相当于目标检测要简单的多。因为目标检测往往除了背景还有其他的类，而文本检测，只需要检测背景和文本类两个问题。因此可以采用目标检测或者分割的方法来进行文本检测。而视频中的文本检测，也可以看做是视频中的目标检测中的一种，感觉应该也可以用视频中的目标检测+跟踪来做。 通常目标跟踪面临的极大难点：物体变形、亮度变化、快速移动、背景干扰覆盖。其中最主要的三个难题分别是目标背景的变化，物体本身的变化，光照强度的变化。 光流法帧间差分法背景差分法]]></content>
  </entry>
  <entry>
    <title><![CDATA[c++中级教程 顺序容器的定义]]></title>
    <url>%2F2019%2F07%2F26%2F%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[顺序容器的定义 顺序容器 vector list deque 顺序容器适配器 stack queue priority_queue]]></content>
      <categories>
        <category>programs</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++中级教程 STL queue]]></title>
    <url>%2F2019%2F07%2F26%2FSTLqueue%2F</url>
    <content type="text"><![CDATA[STL queue 队列： FIFO 先进先出 自适应容器（容器适配器） 栈适配器 STL queue12345678queue&lt;int, deque&lt;int&gt;&gt; q;queue&lt;int, list&lt;int&gt;&gt; q;q.empty()q.size()q.front()q.back()q.pop()q.push(item) 可以用list和deque做queue先进先出，后进后出 12345678910111213141516171819202122232425262728293031323334353637383940// queue.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;list&gt;#include&lt;deque&gt;using namespace std;int main()&#123; queue&lt;int, deque&lt;int&gt;&gt; a; queue&lt;int, list&lt;int&gt;&gt; b; //queue&lt;int, vector&lt;int&gt;&gt; c; 不可以，因为vector不能进行两端操作 //队列有什么用途？？？ queue&lt;int&gt; q; q.push(10); q.push(5); q.push(-1); q.push(20); cout &lt;&lt; "现在队列里有" &lt;&lt; q.size() &lt;&lt; "个数据 " &lt;&lt; endl; cout &lt;&lt; "队首的数据：" &lt;&lt; q.front() &lt;&lt; endl; cout &lt;&lt; "队尾的数据：" &lt;&lt; q.back() &lt;&lt; endl; q.pop(); cout &lt;&lt; "新的队首的数据：" &lt;&lt; q.front() &lt;&lt; endl; while (q.size() != 0) &#123; cout &lt;&lt; " 删除" &lt;&lt; a.front() &lt;&lt; endl; q.pop(); &#125; if (q.empty()) &#123; cout &lt;&lt; "队列为空！"&lt;&lt;endl; &#125; system("pause"); return 0;&#125; 优先级队列 priority_queue 自适应容器（容器适配器）：不能使用list 最大值优先级队列、最小值优先级队列(值越大，优先级越高，值越小优先级越高) 优先级队列适配器 STL priority_queue 1234567891011priority_queue&lt;int, deque&lt;int&gt;&gt; pg1;//对队列里的数据进行随机操作，所以不能使用listpriority_queue&lt;int, vector&lt;int&gt;&gt; pg2; //vector是默认的 //谓词priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; pg2; //vector是默认的，最小优先队列pg.empty()pg.size()pg.top()pg.pop()pg.push(item)~~~~~~~~~~ 1234567891011121314151617181920212223242526272829303132333435363738394041// priority_queue.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include&lt;iostream&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;int main()&#123; priority_queue&lt;int, deque&lt;int&gt;&gt; pg1; //对队列里的数据进行随机操作，所以不能使用list priority_queue&lt;int, vector&lt;int&gt;&gt; pg2; //vector是默认的 //谓词 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; pg2; //vector是默认的，最小优先队列 pg2.push(10); pg2.push(5); pg2.push(-1); pg2.push(20); cout &lt;&lt; &quot;优先级队列一共有： &quot; &lt;&lt; pg2.size() &lt;&lt; &quot;个数据&quot; &lt;&lt; endl; cout &lt;&lt; pg2.top() &lt;&lt; endl; while (!pg2.empty()) &#123; cout &lt;&lt; &quot;从优先级队列里删除： &quot; &lt;&lt; pg2.top() &lt;&lt; endl; pg2.pop(); &#125; system(&quot;pause&quot;); return 0;&#125;优先级队列一共有： 4个数据20从优先级队列里删除： 20从优先级队列里删除： 10从优先级队列里删除： 5从优先级队列里删除： -1请按任意键继续. . .~~]]></content>
      <categories>
        <category>programs</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++中级教程(一)]]></title>
    <url>%2F2019%2F07%2F25%2F%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8-STL-deque-%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[顺序容器 STL deque 类 deque是一个动态数组 deque与vector 非常类似 deque可以在数组开头和末尾插入和删除数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// demo3.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include &lt;iostream&gt;#include &lt;deque&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; deque&lt;int&gt; a; a.push_back(3); a.push_back(4); a.push_back(5); a.push_back(6); //vector只能push_back a.push_front(2); a.push_front(1); a.push_front(9); a.push_front(8); for (size_t nCount = 0; nCount &lt; a.size(); ++nCount) &#123; cout &lt;&lt;"a["&lt;&lt;nCount&lt;&lt;"]" &lt;&lt; "= " &lt;&lt; a[nCount] &lt;&lt; endl; &#125; cout &lt;&lt; endl&lt;&lt;endl; a.pop_front();// 前面删除 a.pop_back();// 后面删除 cout &lt;&lt; "删除之后：" &lt;&lt; endl; /*for (size_t nCount = 0; nCount &lt; a.size(); ++nCount) &#123; cout &lt;&lt; "a[" &lt;&lt; nCount &lt;&lt; "]" &lt;&lt; a[nCount] &lt;&lt; endl; &#125;*/ deque&lt;int&gt;::iterator iElementLocater; //这边使用了迭代器 distence 可以计算当前 for (iElementLocater = a.begin(); iElementLocater != a.end(); ++iElementLocater) &#123; size_t nOffset = distance(a.begin(), iElementLocater);//distence 可以计算当前下标与begin开始的，距离正好是下标 cout &lt;&lt; "a[" &lt;&lt; nOffset &lt;&lt; "]" &lt;&lt; "= "&lt;&lt;*iElementLocater &lt;&lt; endl; &#125; system("pause"); return 0;&#125;a[0]= 8a[1]= 9a[2]= 1a[3]= 2a[4]= 3a[5]= 4a[6]= 5a[7]= 6删除之后：a[0]= 9a[1]= 1a[2]= 2a[3]= 3a[4]= 4a[5]= 5请按任意键继续. . . 順序容器 STL list 類 实例化std::list对象 在list开头插入元素 在list末尾插入元素 在list中间插入元素 删除list中的元素 对list中的元素进行反转和排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// list.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include&lt;iostream&gt;#include&lt;list&gt;using namespace std;void PrintListContent(const list&lt;int&gt;&amp; listInput);int main()&#123; list&lt;int&gt; a; list&lt;int&gt; b; b.push_back(100); b.push_back(200); b.push_back(300); b.push_back(400); b.push_back(500); PrintListContent(b); cout &lt;&lt; endl; a.push_front(4); a.push_front(3); a.push_front(2); a.push_front(1); a.push_back(5); //使用链表数据，不能使用下标，只能使用迭代器 list&lt;int&gt;::iterator iter; iter = a.begin(); a.insert(iter, 10);// 在begin前面插入10，第一个参数迭代器，指定插入的位置 a.insert(a.end(),10); PrintListContent(a); //将b插入到a之中 a.insert(a.begin(), b.begin(), b.end()); a.insert(iter,++b.begin(),--b.end()) PrintListContent(a); system("pause"); return 0;&#125;void PrintListContent(const list&lt;int&gt;&amp; listInput)&#123; //会是一个底层 const，即其所指对象可以改变，但不能改变其所指对象的值。 list&lt;int&gt;::const_iterator iter; for (iter = listInput.begin(); iter != listInput.end(); ++iter) &#123; cout &lt;&lt; *iter &lt;&lt; endl; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// listdelet.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include&lt;iostream&gt;#include&lt;list&gt;using namespace std;void PrintListContent(const list&lt;int&gt;&amp; listInput);int main()&#123; list&lt;int&gt; a; a.push_front(4); a.push_front(3); list&lt;int&gt;::iterator iElementValueTwo; iElementValueTwo = a.insert(a.begin(),2); // inset 才返回迭代器迭代器指向这个位置 a.push_front(1); a.push_back(0); cout &lt;&lt; "删除之前" &lt;&lt; endl; PrintListContent(a); // 删除2 cout &lt;&lt; "删除之后" &lt;&lt; endl; a.erase(iElementValueTwo); //a.erase(a.beigin(),iElementValueTwo); 删除从第一个迭代器到第二个迭代器所有的数据 PrintListContent(a); system("pause"); return 0;&#125;void PrintListContent(const list&lt;int&gt;&amp; listInput)&#123; //会是一个底层 const，即其所指对象可以改变，但不能改变其所指对象的值。 cout &lt;&lt; "&#123;"; list&lt;int&gt;::const_iterator iter; for (iter = listInput.begin(); iter != listInput.end(); ++iter) &#123; cout &lt;&lt; *iter &lt;&lt; " "; &#125; cout &lt;&lt; "&#125;" &lt;&lt; endl;&#125;删除之前&#123;1 2 3 4 0 &#125;删除之后&#123;1 3 4 0 &#125;请按任意键继续. . . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// list3.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include&lt;iostream&gt;#include&lt;list&gt;using namespace std;void PrintListContent(const list&lt;int&gt;&amp; listInput);int main()&#123; list&lt;int&gt; a; a.push_front(4); a.push_front(3); a.push_front(2); a.push_front(1); PrintListContent(a); cout &lt;&lt; "反转之后的数据：" &lt;&lt; endl; a.reverse(); PrintListContent(a); list&lt;int&gt; b; b.push_front(4); b.push_front(53); b.push_front(24); b.push_front(132); PrintListContent(b); cout &lt;&lt; "排序之后的数据：" &lt;&lt; endl; b.sort(); PrintListContent(b); system("pause"); return 0;&#125;void PrintListContent(const list&lt;int&gt;&amp; listInput)&#123; //会是一个底层 const，即其所指对象可以改变，但不能改变其所指对象的值。 cout &lt;&lt; "&#123;"; list&lt;int&gt;::const_iterator iter; for (iter = listInput.begin(); iter != listInput.end(); ++iter) &#123; cout &lt;&lt; *iter &lt;&lt; " "; &#125; cout &lt;&lt; "&#125;" &lt;&lt; endl;&#125;&#123;1 2 3 4 &#125;反转之后的数据：&#123;4 3 2 1 &#125;&#123;132 24 53 4 &#125;排序之后的数据：&#123;4 24 53 132 &#125;请按任意键继续. . .]]></content>
      <categories>
        <category>programs</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++中级教程 STL stack]]></title>
    <url>%2F2019%2F07%2F25%2FSTL-stack%2F</url>
    <content type="text"><![CDATA[STL stack (堆) 栈： LIFO 后进先出 自适应容器（容器适配器） 栈适配器 STL stack1234567stack&lt;int, deque&lt;int&gt;&gt; s;stack&lt;int, vector&lt;int&gt;&gt; s;stack&lt;int, list&lt;int&gt;&gt; s;s.empty()s.size()s.pop()s.push(item) 123456789101112131415161718192021222324252627282930313233343536373839404142434445// stack1.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;stack&gt;using namespace std;int main()&#123; stack&lt;int, deque&lt;int&gt;&gt; a; stack&lt;int, vector&lt;int&gt;&gt; b; stack&lt;int, list&lt;int&gt;&gt; c; stack&lt;int&gt; d; //默认用deque //什么是堆栈？ 先进后出，后进先出 d.push(25); d.push(10); d.push(1); d.push(5); int x = 0; cout &lt;&lt; "现在栈里一共有：" &lt;&lt; d.size() &lt;&lt; "个数据。" &lt;&lt; endl; while (d.empty() == false) &#123; x = d.top(); //查看数据并且返回 d.pop();//删除，不返回 cout &lt;&lt; x &lt;&lt; endl; &#125; //x = d.top(); //查看数据并且返回 //d.pop();//删除，不返回 //cout &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; "现在栈里一共有：" &lt;&lt; d.size() &lt;&lt; "个数据。" &lt;&lt; endl; system("pause"); return 0;&#125;现在栈里一共有：4个数据。511025现在栈里一共有：0个数据。请按任意键继续. . .]]></content>
      <categories>
        <category>programs</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[firstblog]]></title>
    <url>%2F2019%2F07%2F25%2Ffirstblog%2F</url>
    <content type="text"><![CDATA[以上是摘要 Hello World]]></content>
      <categories>
        <category>dailylife</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
