<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法竞赛入门经典第四章]]></title>
    <url>%2F2019%2F08%2F18%2Falgorithm4%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157// t4.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;//素数判断方法2#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;#define Max 1000000#define maxn 100int left, chance; //还需要left位置，错chance之后就会输char s[maxn], s2[maxn]; //答案是字符串s, 玩家猜的字母序列是s2int win, lose; // win=1 表示已经赢了; lose=1 表示已经输了long fac(int n) &#123; if (0 == n || 1 == n) &#123; return 1; &#125; else &#123; return fac(n - 1)*n; &#125;&#125;// 非递归的阶乘方法 long fact(int n)&#123; long iRes = 1; for (int i = 1; i &lt;= n; i++) &#123; iRes *= i; &#125; return iRes;&#125;int combination(int m, int n)&#123; long iRes = fac(n) / (fac(m)*fac(n - m)); // long iRes = fact(n) /(fac(m)*fac(n-m)); printf_s(&quot;%ld %.2lf \n&quot;, iRes, (double)clock() / CLOCKS_PER_SEC); return iRes;&#125;// 刽子手游戏---guess函数void guess(char ch)&#123; int bad = 1; for (int i = 0; i &lt; strlen(s); i++) if (s[i] == ch) &#123; left--; s[i] = &apos; &apos;; bad = 0; &#125; if (bad) --chance; if (!chance) lose = 1; if (!left) win = 1;&#125;int main()&#123; /* 关键: 1 用素数筛选法先预处理，默认刚开始全为素数，然后对素数的倍数标记为非素数， for(int j = i*i ; j &lt;= 10000 ; j += i)&#123;iPrimeArr[j] = 1;&#125; 2 通过开根号判断素数时，可以用floor,注意浮点数加上0.5，int iRadical = floor(sqrt(n*1.0) + 0.5); 3 可以用assert()对输入的合法性进行校验，assert(n &gt;= 5 &amp;&amp; n &lt;= 10000);void assert(int exp),如果表达式的值为0则退出。*/ //int sum = 1; //for (int i = 3; i &lt;= Max; i += 2) //&#123; // //因为偶数除了2 都不是质数 // int j; // for (j = 2; j &lt;= (int)sqrt(i); j++)//利用上述结论判断 // if (i%j == 0) break; // if (j &gt; (int)sqrt(i)) // sum++; //&#125; //printf_s(&quot;Time used = %0.2f s\n&quot;, (double)clock() / CLOCKS_PER_SEC); //printf_s(&quot;%d\n&quot;, sum); //int a, b; //scanf_s(&quot;%d %d&quot;, &amp;a, &amp;b); //combination(a, b); //刽子手游戏 /* 游戏规则是这样的：计算机想一个单词让你猜，你每次可以猜一个字母。 如果单词里有那个字母，所有该字母会显示出来；如果没有那个字母，则计算机会在一幅“刽子手”画上填一笔。 这幅画一共需要7笔就能完成，因此你最多只能错6次。 注意，猜一个已经猜过的字母也算错。 在本题中，你的任务是编写一个“裁判”程序，输入单词和玩家的猜测，判断玩家赢了（You win.）、 输了（You lose.）还是放弃了（You chickened out.）。 每组数据包含3行，第1行是游戏编号（-1为输入结束标记），第2行是计算机想的单词，第3行是玩家的猜测。 后两行保证只含小写字母。 */ //char ans[21]; //char gus[28]; //int times, yes; //int chances = 7; //int win = 0; //int lose = 0; //scanf_s(&quot;%d&quot;, &amp;times); //while (times != -1) //&#123; // printf_s(&quot;Round %d\n&quot;, times); // scanf_s(&quot;%s\n %s&quot;, ans, gus); // printf_s(&quot;Round %s &amp;s\n&quot;, ans, gus); // yes = 0; // win = 0, lose = 0, chances = 7; // for (int i = 0; i &lt; strlen(gus); i++) // &#123; // int flag = 0; // for (int j = 0; j &lt; strlen(ans); j++) // &#123; // if (ans[j] == gus[i]) // &#123; // yes++; // flag = 1;//找到之后不退出，因为有一个有相同的字母 // &#125; // if (flag == 0) // &#123; // chances--; // &#125; // if (chances == 0) // &#123; // lose = 1; // printf_s(&quot;You lose.\n&quot;); // &#125; // else if (yes == strlen(ans)) // &#123; // win = 1; // printf_s(&quot;You win.\n&quot;); // break; // &#125; // if (win != 1 &amp;&amp; lose != 1) // &#123; // printf(&quot;You chickened out.\n&quot;); // &#125; // scanf_s(&quot;%d&quot;, &amp;times); // &#125; // &#125; //&#125; int rnd; while (scanf_s(&quot;%d%s%s&quot;, &amp;rnd, &amp;s, &amp;s2) == 3 &amp;&amp; rnd != -1) &#123; printf_s(&quot;%Round %d\n&quot;, rnd); win = lose = 0; left = strlen(s); chance = 7; for (int i = 0; i &lt; strlen(s2); i++) &#123; guess(s2[i]); //猜一个字母 if (win || lose) break; //检查状态 &#125; //根据结果进行输出 if (win) printf_s(&quot;You win.\n&quot;); else if (lose) printf_s(&quot;You lose.\n&quot;); else printf_s(&quot;You chickened out.\n&quot;); &#125; system(&quot;pause&quot;); return 0;&#125;]]></content>
      <categories>
        <category>programs</category>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典第三章]]></title>
    <url>%2F2019%2F08%2F16%2Falgorithm3%2F</url>
    <content type="text"><![CDATA[今天心情不好，所以就敲了这一点代码，希望明天的状态能好一点！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// t3.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &quot;stdio.h&quot;#include &lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;#define maxn 10000000 +10char s[maxn];int main()&#123; //题目1 统计个数 /*int count =0; int temp; while (~scanf_s(&quot;%d&quot;, &amp;temp)) &#123; count++; &#125; printf_s(&quot;%d&quot;, count);*/ //显示不出来 //输入一些数，求最大值、最小值和平均数 //int min, max, n, sum,count = 0; //float avg; //scanf_s(&quot;%d&quot;, &amp;n); //max = n; //min = n; //sum = n; //count++; //while (scanf_s(&quot;%d&quot;, &amp;n)!=EOF) //&#123; // count++; // sum += n; // if (n &gt; max) // max = n; // if (n &lt; min) // min = n; //&#125; //avg = sum*1.0 / count; //printf_s(&quot;%d %d %f\n&quot;, max,min,avg); //5.输入一些数 ，求出他们的方差 /*double ave, sum = 0, varance, psum = 0; int n.a[110], count = 0; while (scanf_s(&quot;%d&quot;, &amp;n) != EOF) &#123; a[count++] = n; sum += n; &#125; avg = sum*1.0 / count; for (int i = 0; i &lt; count; i++) psum += (a[i] - ave)*(a[i] - ave); variance = psum / count; print(&quot;%lf&quot;, variance);*/ scanf_s(&quot;%s&quot;, s); int tot = 0; for (int i = 0;s[i]; i++) &#123; if (s[i] == &apos;1&apos;) tot++; &#125; printf_s(&quot;%d\n&quot;, tot); system(&quot;pause&quot;); return 0;&#125;]]></content>
      <categories>
        <category>programs</category>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LNMS]]></title>
    <url>%2F2019%2F08%2F16%2FLNMS%2F</url>
    <content type="text"><![CDATA[locality NMSLNMS是在EAST文本检测中提出的．主要原因：文本检测面临的是成千上万个几何体，如果用普通的NMS，其计算复杂度，n是几何体的个数，这是不可接受的．对上述时间复杂度问题，EAST提出了基于行合并几何体的方法，当然这是基于邻近几个几何体是高度相关的假设．注意：这里合并的四边形坐标是通过两个给定四边形的得分进行加权平均的，也就是说这里是“平均”而不是”选择”几何体*,目的是减少计算量．基本步骤1.先对所有的output box集合结合相应的阈值（大于阈值则进行合并，小于阈值则不和并），依次遍历进行加权合并，得到合并后的bbox集合；2.对合并后的bbox集合进行标准的NMS操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344def detect(score_map, geo_map, timer, score_map_thresh=1e-5, box_thresh=1e-8, nms_thres=0.1): &apos;&apos;&apos; restore text boxes from score map and geo map :param score_map: bs* 128 * 128 * 1 :param geo_map: ## geo_map = bs * 128 * 128 * 5 :param timer: :param score_map_thresh: threshhold for score map :param box_thresh: threshhold for boxes :param nms_thres: threshold for nms :return: &apos;&apos;&apos; if len(score_map.shape) == 4: score_map = score_map[0, :, :, 0] geo_map = geo_map[0, :, :, ] # filter the score map xy_text = np.argwhere(score_map &gt; score_map_thresh) # sort the text boxes via the y axis xy_text = xy_text[np.argsort(xy_text[:, 0])] # restore start = time.time() text_box_restored = restore_rectangle(xy_text[:, ::-1]*4, geo_map[xy_text[:, 0], xy_text[:, 1], :]) # N*4*2 #print(&apos;&#123;&#125; text boxes before nms&apos;.format(text_box_restored.shape[0])) boxes = np.zeros((text_box_restored.shape[0], 9), dtype=np.float32) boxes[:, :8] = text_box_restored.reshape((-1, 8)) boxes[:, 8] = score_map[xy_text[:, 0], xy_text[:, 1]] timer[&apos;restore&apos;] = time.time() - start # 得到box 的坐标以及分数 # nms part start = time.time() # boxes = nms_locality.nms_locality(boxes.astype(np.float64), nms_thres) boxes = lanms.merge_quadrangle_n9(boxes.astype(&apos;float32&apos;), nms_thres) timer[&apos;nms&apos;] = time.time() - start if boxes.shape[0] == 0: return None, timer # here we filter some low score boxes by the average score map, this is different from the orginal paper for i, box in enumerate(boxes): mask = np.zeros_like(score_map, dtype=np.uint8) cv2.fillPoly(mask, box[:8].reshape((-1, 4, 2)).astype(np.int32) // 4, 1) boxes[i, 8] = cv2.mean(score_map, mask)[0] boxes = boxes[boxes[:, 8] &gt; box_thresh] return boxes, timer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import numpy as npfrom shapely.geometry import Polygondef intersection(g, p): #取g,p中的几何体信息组成多边形 g = Polygon(g[:8].reshape((4, 2))) p = Polygon(p[:8].reshape((4, 2))) # 判断g,p是否为有效的多边形几何体 if not g.is_valid or not p.is_valid: return 0 # 取两个几何体的交集和并集 inter = Polygon(g).intersection(Polygon(p)).area union = g.area + p.area - inter if union == 0: return 0 else: return inter/uniondef weighted_merge(g, p): # 取g,p两个几何体的加权（权重根据对应的检测得分计算得到） g[:8] = (g[8] * g[:8] + p[8] * p[:8])/(g[8] + p[8]) #合并后的几何体的得分为两个几何体得分的总和 g[8] = (g[8] + p[8]) return gdef standard_nms(S, thres): #标准NMS order = np.argsort(S[:, 8])[::-1] keep = [] while order.size &gt; 0: i = order[0] keep.append(i) ovr = np.array([intersection(S[i], S[t]) for t in order[1:]]) inds = np.where(ovr &lt;= thres)[0] order = order[inds+1] return S[keep]def nms_locality(polys, thres=0.3): &apos;&apos;&apos; locality aware nms of EAST :param polys: a N*9 numpy array. first 8 coordinates, then prob :return: boxes after nms &apos;&apos;&apos; S = [] #合并后的几何体集合 p = None #合并后的几何体 for g in polys: if p is not None and intersection(g, p) &gt; thres: #若两个几何体的相交面积大于指定的阈值，则进行合并 p = weighted_merge(g, p) else: #反之，则保留当前的几何体 if p is not None: S.append(p) p = g if p is not None: S.append(p) if len(S) == 0: return np.array([]) return standard_nms(np.array(S), thres)if __name__ == &apos;__main__&apos;: # 343,350,448,135,474,143,369,359 print(Polygon(np.array([[343, 350], [448, 135], [474, 143], [369, 359]])).area) 参考博客： https://www.jianshu.com/p/4934875f7eb6]]></content>
      <categories>
        <category>programs</category>
        <category>algorithm</category>
        <category>cv</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>nms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典第二章]]></title>
    <url>%2F2019%2F08%2F15%2Falgorithm2%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187// t2.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &quot;stdio.h&quot;#include &lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;int main()&#123; ////3n+1问题、 //int n, count = 0; //当n过大的时候 2*n溢出 // //scanf_s(&quot;%d&quot;, &amp;n); //long long n2 = n; //while (n2 &gt; 1) //&#123; // if (n2 % 2 == 1) n2 = n2 * 3 + 1; // else n2 /= 2; // count++; //&#125; //printf_s(&quot;%d\n&quot;, count); //近似计算 /*double sum = 0; for (int i = 0;; i++) &#123; double term = 1.0 / (i * 2 + 1); if (i % 2 == 0) sum += term; else sum -= term; if (term &lt; 1e-6) break; &#125; printf_s(&quot;%.6f\n&quot;, sum);*/ // 阶乘之和 只保存后六位 //int n, S = 0; //scanf_s(&quot;%d&quot;, &amp;n); //for (int i = 1; i &lt;= n; i++) //&#123; // int factorial = 1; // for (int j = 1; j &lt;= i; j++) // factorial *= j; // S += factorial; //&#125; //printf_s(&quot;%d\n&quot;, S % 1000000); // 阶乘之和2, 优化版本 //int n, S = 0; //const int MOD = 1000000; //scanf_s(&quot;%d&quot;, &amp;n); //for (int i = 1; i &lt;= n; i++) //&#123; // int factorial = 1; // for (int j = 1; j &lt;= i; j++) // factorial = (factorial *j)%MOD; // S += factorial; //&#125; //printf_s(&quot;%d\n&quot;, S %MOD); //printf_s(&quot;Time used = %.2f\n&quot;, (double)clock() / CLOCKS_PER_SEC); // 得到程序运行的时间 单位：秒 // 数据统计 //习题2.1 水仙花数目 /*int sum; for (int i = 1; i &lt; 10; i++) for (int k = 0; k &lt; 10; k++) for (int j = 0; j &lt; 10; j++) &#123; sum = i * 100 + 10 * k + j; if(sum == i*i*i+j*j*j + k*k*k) printf_s(&quot;%d &quot;, sum); &#125;*/ //习题2.2 韩信点兵 相传韩信才智过人，从不直接清点自己军队的人数，只要让士兵先后以三人一排、五人一排、七人一排地变换队形， //而他每次只掠一眼队伍的排尾就知道总人数了。输入包含多组数据，每组数据包含3个非负整数a，b，c，表示每种队形排尾的人数（a＜3，b＜5，c＜7）， //输出总人数的最小值（或报告无解）。已知总人数不小于10，不超过100。输入到文件结束为止。 //int i, a, b, c; //scanf_s(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); //for (i = 0; i &lt;= 100; i++) &#123; // if (i % 3 == a &amp;&amp; i % 5 == b &amp;&amp; i % 7 == c) // printf_s(&quot;%d\n&quot;, i); // //&#125; //if (i % 3 != a &amp;&amp; i % 5 != b &amp;&amp; i % 7 != c &amp;&amp; i&gt;100) // printf_s(&quot;No answer\n&quot;); //习题2.3 倒三角形 //int n, /* 输出n行; n&lt;=20 */ // i, /* 打印第i行 */ // j; //scanf_s(&quot;%d&quot;, &amp;n); //for (i = 1; i &lt;= n; i = i + 1) &#123; // /* 在第i行，打印(i-1)个空格 */ // for (j = 1; j &lt;= i - 1; j = j + 1) printf_s(&quot; &quot;); // /* 在第i行，打印(2*n-2*i+1)个# */ // for (j = 1; j &lt;= (2 * n - 2 * i + 1); j = j + 1) printf_s(&quot;#&quot;); // printf_s(&quot;\n&quot;); /* 输出结束后换行，否则所有的#号在同一行输出 */ //&#125; //习题2.4 子序列的和 输入两个正整数n＜m＜10 6 ，输出 ，保留5位小数。输入包含多组数据， 注：陷阱就是在n特别大时如果直接n*n就会溢出，所以只能连除两次 //int count = 0; //while (1) &#123; // int n = 0; // int m = 0; // scanf_s(&quot;%d&quot;, &amp;n); // scanf_s(&quot;%d&quot;, &amp;m); // if (n == m&amp;&amp;n == 0) &#123; // break; // &#125; // count++; // double sum = 0; // for (int i = n; i &lt;= m; i++) &#123; // sum += 1.0 / i / i; // &#125; // printf_s(&quot;Case %d:%.5f\n&quot;, count, sum); //&#125; //习题2.5 分数化小数（decimal） //输入正整数a，b，c，输出a / b的小数形式，精确到小数点后c位。a，b≤10 ^ 6，c≤100。输入包含多组数据，结束标记为a＝b＝c＝0。 // int count = 0; //while (1) &#123; // int a, b, c; // int k, d, i; // scanf_s(&quot;%d&quot;, &amp;a); // scanf_s(&quot;%d&quot;, &amp;b); // scanf_s(&quot;%d&quot;, &amp;c); // if (a == 0&amp;&amp;b == 0 &amp;&amp;c==0 ) &#123; // break; // &#125; // count++; // for (i = 0; i&lt;c - 1; i++) // &#123; // /*机智地把余数放大十倍，使之除以b并取模*/ // k = (k%b) * 10; // printf_s(&quot;Case %d:%.5f\n&quot;, count, k / b); // &#125; // k = (k%b) * 10; // d = (k%b) * 10 / b; // if (d &gt;= 5)//判断第c+1位小数是否大于等于5，if yes,第c位小数要进1 // &#123; // printf_s(&quot;Case %d:%.5f\n&quot;, count, k / b + 1); // &#125; // else // &#123; // printf_s(&quot;Case %d:%.5f\n&quot;, count, k / b); // &#125; // //&#125; int abc,def,ghi; int a[10],count=0; memset(a,0,sizeof(a)); // 将a数组中的值全部设置为0 for (abc = 123;abc &lt; 333;abc ++) &#123; // 基本可以确定abc的最小值和最大值 def = 2 * abc; ghi = 3 * abc; // 设置数组中所有对应的9位数字位置的值1 a[abc/100] = 1; // a a[abc/10%10] = 1; // b a[abc%10] = 1; // c a[def/100] = 1; // d a[def/10%10] = 1; // e a[def%10] = 1; // f a[ghi/100] = 1; // g a[ghi/10%10] = 1; // h a[ghi%10] = 1; // i int i; for (i=1;i&lt;=9;i++) &#123; count += a[i]; &#125; if (count == 9) &#123; printf_s(&quot;%d %d %d\n&quot;,abc,def,ghi); &#125; // 重置count 和a数组 count = 0; memset(a,0,sizeof(a)); &#125; system(&quot;pause&quot;); return 0; &#125;]]></content>
      <categories>
        <category>programs</category>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典第一章]]></title>
    <url>%2F2019%2F08%2F14%2Falgorithm1%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// t1.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &quot;stdio.h&quot;#include &lt;stdlib.h&gt;#include&lt;math.h&gt; int main()&#123; //printf(&quot;%.1f\n&quot;, 8.0 / 5.0); // %点后面是保留几位浮点小数1.6 //printf(&quot;%.1f\n&quot;, 8 / 5); // %点后面是保留几位浮点小数 结果为0 //printf(&quot;%d\n&quot;, 8.0 / 5.0); // 整数值用%d输出，实数用%f输出 # int 是2字节 ，float是4字节 溢出 // //整数/整数等与整数，浮点数除以浮点数等于浮点数 //printf(&quot;%.8f\n&quot;, 1 + 2 * sqrt(3) / (5 - 0.1)); //int a, b; //scanf_s(&quot;%d%d&quot;, &amp;a, &amp;b); //scanf_s 中的占位符要和变量的数据类型一一对应，要在变量前面加上“&amp;”符号 //printf(&quot;%d\n&quot;, a+b); //const double pi = acos(-1.0); //double r, h, s1, s2, s; //scanf_s(&quot;%1f%1f&quot;, &amp;r, &amp;h); //s1 = pi*r*r; //s2 = 2 * pi*r*h; //s = s1*2.0 + s2; //printf_s(&quot;Area = %.3f\n&quot;, s); //交换变量 //int a, b, m, n; //scanf_s(&quot;%d%d&quot;, &amp;a, &amp;b); ///*a = a + b; //b = a - b; //a = a - b;*/ //printf_s(&quot;%d %d\n&quot;, b, a); //int a, b, m, n; //scanf_s(&quot;%d%d&quot;, &amp;n, &amp;m); ///*a = a + b; //b = a - b; //a = a - b;*/ //a = (4*n-m) / 2; //b = n - a; //if (m % 2 == 1 || a &lt; 0 || b &lt; 0) // printf_s(&quot;No answer!\n&quot;); //else // printf_s(&quot;Answer is chicken %d rabbit %d\n&quot;, a, b); //exp1 输入三个整数，求出他们的平均数，保留三位小数 //int a, b, c; //scanf_s(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); //printf_s(&quot;%.3f&quot;, (a + b + c) / 3.0); //exp2 输入华氏温度f,输出对应的摄氏温度c,保留3位小数.提示 : c = 5(f-32)/9. //float f, c; //scanf_s(&quot;%f&quot;, &amp;f); //c = 5*(f - 32) / 9.0; //printf_s(&quot;摄制温度为： %.3f&quot;, c); //exp3 //int n; //scanf_s(&quot;%d&quot;, &amp;n); //printf_s(&quot;%d&quot;, n*(n + 1) / 2); //exp4 输入正整数《360 ，输出正弦余弦函数值。提示：使用数学函数 //int n; // #define PI 3.1415926 //scanf_s(&quot;%d&quot;, &amp;n); //if (n &lt; 0 || n&gt;360) // printf_s(&quot;error&quot;); //else //&#123; // printf_s(&quot;%.2f\n&quot;, cos(n*PI/180)); // printf_s(&quot;%.2f&quot;, sin(n*PI / 180)); //&#125; // // exp5 一件衣服95元，若消费满300元可以打85折，输入购买衣服的简书，输出需要支付的金额。保留两位小数 //int n,money; //scanf_s(&quot;%d&quot;, &amp;n); //money = n * 95; //if (money &gt; 300) // printf_s(&quot;%.2f&quot;, money* 0.85); //else // printf_s(&quot;%.2f&quot;, money); // //exp6 判断三个边是否能构成直角三角形 边长均为正整数 //int a, b, c; //scanf_s(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); //if (((a*a + b*b)== c*c) || ((a*a + c*c) == b*b) || ((c*c + b*b) == a*a)) // printf_s(&quot;yes\n&quot;); //else // printf_s(&quot;not a triangle\n&quot;); //exp7 判断一个年是不是闰年 能被4整除但是不能被100整除的年份 //int n; //scanf_s(&quot;%d&quot;, &amp;n); //if (n % 4 == 0 &amp;&amp; n % 100 != 0) // printf_s(&quot;yes\n&quot;); //else // printf_s(&quot;no\n&quot;); // //q1: int类型的最大值和最小值是多少 2^(n - 1) - 1 -2^(n - 1) //q2; double浮点数能精确到多少位小数？ 遵循IEEE标准的8字节（64位）的double能表示的有效数字的位数是：15 ~ 16 //q3: double类型的最大正数值和最小正数值 //q4: 逻辑运算符号的优先级 system(&quot;pause&quot;); return 0;&#125; 思考题解析： https://blog.csdn.net/panderang/article/details/54096426]]></content>
      <categories>
        <category>programs</category>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F07%2F29%2F%E6%96%87%E6%9C%AC%E6%A3%80%E6%B5%8B%E8%B0%83%E7%A0%94%2F</url>
    <content type="text"><![CDATA[文本检测问题，广义上来说可以看做是一个目标检测的问题，但是相当于目标检测要简单的多。因为目标检测往往除了背景还有其他的类，而文本检测，只需要检测背景和文本类两个问题。因此可以采用目标检测或者分割的方法来进行文本检测。而视频中的文本检测，也可以看做是视频中的目标检测中的一种，感觉应该也可以用视频中的目标检测+跟踪来做。 通常目标跟踪面临的极大难点：物体变形、亮度变化、快速移动、背景干扰覆盖。其中最主要的三个难题分别是目标背景的变化，物体本身的变化，光照强度的变化。 光流法帧间差分法背景差分法]]></content>
  </entry>
  <entry>
    <title><![CDATA[c++中级教程 顺序容器的定义]]></title>
    <url>%2F2019%2F07%2F26%2F%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[顺序容器的定义 顺序容器 vector list deque 顺序容器适配器 stack queue priority_queue]]></content>
      <categories>
        <category>programs</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++中级教程 STL queue]]></title>
    <url>%2F2019%2F07%2F26%2FSTLqueue%2F</url>
    <content type="text"><![CDATA[STL queue 队列： FIFO 先进先出 自适应容器（容器适配器） 栈适配器 STL queue12345678queue&lt;int, deque&lt;int&gt;&gt; q;queue&lt;int, list&lt;int&gt;&gt; q;q.empty()q.size()q.front()q.back()q.pop()q.push(item) 可以用list和deque做queue先进先出，后进后出 12345678910111213141516171819202122232425262728293031323334353637383940// queue.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;list&gt;#include&lt;deque&gt;using namespace std;int main()&#123; queue&lt;int, deque&lt;int&gt;&gt; a; queue&lt;int, list&lt;int&gt;&gt; b; //queue&lt;int, vector&lt;int&gt;&gt; c; 不可以，因为vector不能进行两端操作 //队列有什么用途？？？ queue&lt;int&gt; q; q.push(10); q.push(5); q.push(-1); q.push(20); cout &lt;&lt; "现在队列里有" &lt;&lt; q.size() &lt;&lt; "个数据 " &lt;&lt; endl; cout &lt;&lt; "队首的数据：" &lt;&lt; q.front() &lt;&lt; endl; cout &lt;&lt; "队尾的数据：" &lt;&lt; q.back() &lt;&lt; endl; q.pop(); cout &lt;&lt; "新的队首的数据：" &lt;&lt; q.front() &lt;&lt; endl; while (q.size() != 0) &#123; cout &lt;&lt; " 删除" &lt;&lt; a.front() &lt;&lt; endl; q.pop(); &#125; if (q.empty()) &#123; cout &lt;&lt; "队列为空！"&lt;&lt;endl; &#125; system("pause"); return 0;&#125; 优先级队列 priority_queue 自适应容器（容器适配器）：不能使用list 最大值优先级队列、最小值优先级队列(值越大，优先级越高，值越小优先级越高) 优先级队列适配器 STL priority_queue 1234567891011priority_queue&lt;int, deque&lt;int&gt;&gt; pg1;//对队列里的数据进行随机操作，所以不能使用listpriority_queue&lt;int, vector&lt;int&gt;&gt; pg2; //vector是默认的 //谓词priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; pg2; //vector是默认的，最小优先队列pg.empty()pg.size()pg.top()pg.pop()pg.push(item)~~~~~~~~~~ 1234567891011121314151617181920212223242526272829303132333435363738394041// priority_queue.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include&lt;iostream&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;int main()&#123; priority_queue&lt;int, deque&lt;int&gt;&gt; pg1; //对队列里的数据进行随机操作，所以不能使用list priority_queue&lt;int, vector&lt;int&gt;&gt; pg2; //vector是默认的 //谓词 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; pg2; //vector是默认的，最小优先队列 pg2.push(10); pg2.push(5); pg2.push(-1); pg2.push(20); cout &lt;&lt; &quot;优先级队列一共有： &quot; &lt;&lt; pg2.size() &lt;&lt; &quot;个数据&quot; &lt;&lt; endl; cout &lt;&lt; pg2.top() &lt;&lt; endl; while (!pg2.empty()) &#123; cout &lt;&lt; &quot;从优先级队列里删除： &quot; &lt;&lt; pg2.top() &lt;&lt; endl; pg2.pop(); &#125; system(&quot;pause&quot;); return 0;&#125;优先级队列一共有： 4个数据20从优先级队列里删除： 20从优先级队列里删除： 10从优先级队列里删除： 5从优先级队列里删除： -1请按任意键继续. . .~~]]></content>
      <categories>
        <category>programs</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++中级教程 STL stack]]></title>
    <url>%2F2019%2F07%2F25%2FSTL-stack%2F</url>
    <content type="text"><![CDATA[STL stack (堆) 栈： LIFO 后进先出 自适应容器（容器适配器） 栈适配器 STL stack1234567stack&lt;int, deque&lt;int&gt;&gt; s;stack&lt;int, vector&lt;int&gt;&gt; s;stack&lt;int, list&lt;int&gt;&gt; s;s.empty()s.size()s.pop()s.push(item) 123456789101112131415161718192021222324252627282930313233343536373839404142434445// stack1.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;stack&gt;using namespace std;int main()&#123; stack&lt;int, deque&lt;int&gt;&gt; a; stack&lt;int, vector&lt;int&gt;&gt; b; stack&lt;int, list&lt;int&gt;&gt; c; stack&lt;int&gt; d; //默认用deque //什么是堆栈？ 先进后出，后进先出 d.push(25); d.push(10); d.push(1); d.push(5); int x = 0; cout &lt;&lt; "现在栈里一共有：" &lt;&lt; d.size() &lt;&lt; "个数据。" &lt;&lt; endl; while (d.empty() == false) &#123; x = d.top(); //查看数据并且返回 d.pop();//删除，不返回 cout &lt;&lt; x &lt;&lt; endl; &#125; //x = d.top(); //查看数据并且返回 //d.pop();//删除，不返回 //cout &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; "现在栈里一共有：" &lt;&lt; d.size() &lt;&lt; "个数据。" &lt;&lt; endl; system("pause"); return 0;&#125;现在栈里一共有：4个数据。511025现在栈里一共有：0个数据。请按任意键继续. . .]]></content>
      <categories>
        <category>programs</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++中级教程(一)]]></title>
    <url>%2F2019%2F07%2F25%2F%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8-STL-deque-%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[顺序容器 STL deque 类 deque是一个动态数组 deque与vector 非常类似 deque可以在数组开头和末尾插入和删除数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// demo3.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include &lt;iostream&gt;#include &lt;deque&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; deque&lt;int&gt; a; a.push_back(3); a.push_back(4); a.push_back(5); a.push_back(6); //vector只能push_back a.push_front(2); a.push_front(1); a.push_front(9); a.push_front(8); for (size_t nCount = 0; nCount &lt; a.size(); ++nCount) &#123; cout &lt;&lt;"a["&lt;&lt;nCount&lt;&lt;"]" &lt;&lt; "= " &lt;&lt; a[nCount] &lt;&lt; endl; &#125; cout &lt;&lt; endl&lt;&lt;endl; a.pop_front();// 前面删除 a.pop_back();// 后面删除 cout &lt;&lt; "删除之后：" &lt;&lt; endl; /*for (size_t nCount = 0; nCount &lt; a.size(); ++nCount) &#123; cout &lt;&lt; "a[" &lt;&lt; nCount &lt;&lt; "]" &lt;&lt; a[nCount] &lt;&lt; endl; &#125;*/ deque&lt;int&gt;::iterator iElementLocater; //这边使用了迭代器 distence 可以计算当前 for (iElementLocater = a.begin(); iElementLocater != a.end(); ++iElementLocater) &#123; size_t nOffset = distance(a.begin(), iElementLocater);//distence 可以计算当前下标与begin开始的，距离正好是下标 cout &lt;&lt; "a[" &lt;&lt; nOffset &lt;&lt; "]" &lt;&lt; "= "&lt;&lt;*iElementLocater &lt;&lt; endl; &#125; system("pause"); return 0;&#125;a[0]= 8a[1]= 9a[2]= 1a[3]= 2a[4]= 3a[5]= 4a[6]= 5a[7]= 6删除之后：a[0]= 9a[1]= 1a[2]= 2a[3]= 3a[4]= 4a[5]= 5请按任意键继续. . . 順序容器 STL list 類 实例化std::list对象 在list开头插入元素 在list末尾插入元素 在list中间插入元素 删除list中的元素 对list中的元素进行反转和排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// list.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include&lt;iostream&gt;#include&lt;list&gt;using namespace std;void PrintListContent(const list&lt;int&gt;&amp; listInput);int main()&#123; list&lt;int&gt; a; list&lt;int&gt; b; b.push_back(100); b.push_back(200); b.push_back(300); b.push_back(400); b.push_back(500); PrintListContent(b); cout &lt;&lt; endl; a.push_front(4); a.push_front(3); a.push_front(2); a.push_front(1); a.push_back(5); //使用链表数据，不能使用下标，只能使用迭代器 list&lt;int&gt;::iterator iter; iter = a.begin(); a.insert(iter, 10);// 在begin前面插入10，第一个参数迭代器，指定插入的位置 a.insert(a.end(),10); PrintListContent(a); //将b插入到a之中 a.insert(a.begin(), b.begin(), b.end()); a.insert(iter,++b.begin(),--b.end()) PrintListContent(a); system("pause"); return 0;&#125;void PrintListContent(const list&lt;int&gt;&amp; listInput)&#123; //会是一个底层 const，即其所指对象可以改变，但不能改变其所指对象的值。 list&lt;int&gt;::const_iterator iter; for (iter = listInput.begin(); iter != listInput.end(); ++iter) &#123; cout &lt;&lt; *iter &lt;&lt; endl; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// listdelet.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include&lt;iostream&gt;#include&lt;list&gt;using namespace std;void PrintListContent(const list&lt;int&gt;&amp; listInput);int main()&#123; list&lt;int&gt; a; a.push_front(4); a.push_front(3); list&lt;int&gt;::iterator iElementValueTwo; iElementValueTwo = a.insert(a.begin(),2); // inset 才返回迭代器迭代器指向这个位置 a.push_front(1); a.push_back(0); cout &lt;&lt; "删除之前" &lt;&lt; endl; PrintListContent(a); // 删除2 cout &lt;&lt; "删除之后" &lt;&lt; endl; a.erase(iElementValueTwo); //a.erase(a.beigin(),iElementValueTwo); 删除从第一个迭代器到第二个迭代器所有的数据 PrintListContent(a); system("pause"); return 0;&#125;void PrintListContent(const list&lt;int&gt;&amp; listInput)&#123; //会是一个底层 const，即其所指对象可以改变，但不能改变其所指对象的值。 cout &lt;&lt; "&#123;"; list&lt;int&gt;::const_iterator iter; for (iter = listInput.begin(); iter != listInput.end(); ++iter) &#123; cout &lt;&lt; *iter &lt;&lt; " "; &#125; cout &lt;&lt; "&#125;" &lt;&lt; endl;&#125;删除之前&#123;1 2 3 4 0 &#125;删除之后&#123;1 3 4 0 &#125;请按任意键继续. . . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// list3.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include&lt;iostream&gt;#include&lt;list&gt;using namespace std;void PrintListContent(const list&lt;int&gt;&amp; listInput);int main()&#123; list&lt;int&gt; a; a.push_front(4); a.push_front(3); a.push_front(2); a.push_front(1); PrintListContent(a); cout &lt;&lt; "反转之后的数据：" &lt;&lt; endl; a.reverse(); PrintListContent(a); list&lt;int&gt; b; b.push_front(4); b.push_front(53); b.push_front(24); b.push_front(132); PrintListContent(b); cout &lt;&lt; "排序之后的数据：" &lt;&lt; endl; b.sort(); PrintListContent(b); system("pause"); return 0;&#125;void PrintListContent(const list&lt;int&gt;&amp; listInput)&#123; //会是一个底层 const，即其所指对象可以改变，但不能改变其所指对象的值。 cout &lt;&lt; "&#123;"; list&lt;int&gt;::const_iterator iter; for (iter = listInput.begin(); iter != listInput.end(); ++iter) &#123; cout &lt;&lt; *iter &lt;&lt; " "; &#125; cout &lt;&lt; "&#125;" &lt;&lt; endl;&#125;&#123;1 2 3 4 &#125;反转之后的数据：&#123;4 3 2 1 &#125;&#123;132 24 53 4 &#125;排序之后的数据：&#123;4 24 53 132 &#125;请按任意键继续. . .]]></content>
      <categories>
        <category>programs</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[firstblog]]></title>
    <url>%2F2019%2F07%2F25%2Ffirstblog%2F</url>
    <content type="text"><![CDATA[以上是摘要 Hello World]]></content>
      <categories>
        <category>dailylife</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
